diff --git a/node_modules/react-native-reanimated/android/build/intermediates/aar_metadata/debug/aar-metadata.properties b/node_modules/react-native-reanimated/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
new file mode 100644
index 0000000..776557e
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
@@ -0,0 +1,5 @@
+aarFormatVersion=1.0
+aarMetadataVersion=1.0
+minCompileSdk=1
+minCompileSdkExtension=0
+minAndroidGradlePluginVersion=1.0.0
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a.json b/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a.json
new file mode 100644
index 0000000..e542dae
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a.json
@@ -0,0 +1,14 @@
+{
+  "allAbis": [
+    "armeabi-v7a",
+    "arm64-v8a",
+    "x86",
+    "x86_64"
+  ],
+  "validAbis": [
+    "ARMEABI_V7A",
+    "ARM64_V8A",
+    "X86",
+    "X86_64"
+  ]
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a.log b/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a.log
new file mode 100644
index 0000000..0637a08
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a.log
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a_key.json b/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a_key.json
new file mode 100644
index 0000000..a444d81
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/abi_configuration_4i3a4k2a_key.json
@@ -0,0 +1,23 @@
+{
+  "ndkHandlerSupportedAbis": [
+    "ARMEABI_V7A",
+    "ARM64_V8A",
+    "X86",
+    "X86_64"
+  ],
+  "ndkHandlerDefaultAbis": [
+    "ARMEABI_V7A",
+    "ARM64_V8A",
+    "X86",
+    "X86_64"
+  ],
+  "externalNativeBuildAbiFilters": [
+    "x86_64",
+    "x86",
+    "armeabi-v7a",
+    "arm64-v8a"
+  ],
+  "ndkConfigAbiFilters": [],
+  "splitsFilterAbis": [],
+  "ideBuildOnlyTargetAbi": true
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/create_cxx_tasks_23_timing.txt b/node_modules/react-native-reanimated/android/build/intermediates/cxx/create_cxx_tasks_23_timing.txt
new file mode 100644
index 0000000..918143d
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/create_cxx_tasks_23_timing.txt
@@ -0,0 +1,6 @@
+# C/C++ build system timings
+create_cxx_tasks
+  create-initial-cxx-model 16ms
+  [gap of 11ms]
+create_cxx_tasks completed in 27ms
+
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35.json b/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35.json
new file mode 100644
index 0000000..69bbe28
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35.json
@@ -0,0 +1,11 @@
+{
+  "ndk": "/Users/sabiha.durmaz/Library/Android/sdk/ndk/23.1.7779620",
+  "revision": {
+    "mMajor": 23,
+    "mMinor": 1,
+    "mMicro": 7779620,
+    "mPreview": 0,
+    "mPrecision": "MICRO",
+    "mPreviewSeparator": " "
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35.log b/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35.log
new file mode 100644
index 0000000..f23160f
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35.log
@@ -0,0 +1,72 @@
+[
+  {
+    "level_": 0,
+    "message_": "android.ndkVersion from module build.gradle is [23.1.7779620]",
+    "file_": "",
+    "tag_": "",
+    "diagnosticCode_": 0,
+    "memoizedIsInitialized": 1,
+    "unknownFields": {
+      "fields": {},
+      "fieldsDescending": {}
+    },
+    "memoizedSize": -1,
+    "memoizedHashCode": -1916879030
+  },
+  {
+    "level_": 0,
+    "message_": "android.ndkPath from module build.gradle is not set",
+    "file_": "",
+    "tag_": "",
+    "diagnosticCode_": 0,
+    "memoizedIsInitialized": 1,
+    "unknownFields": {
+      "fields": {},
+      "fieldsDescending": {}
+    },
+    "memoizedSize": -1,
+    "memoizedHashCode": -108135788
+  },
+  {
+    "level_": 0,
+    "message_": "ndk.dir in local.properties is not set",
+    "file_": "",
+    "tag_": "",
+    "diagnosticCode_": 0,
+    "memoizedIsInitialized": 1,
+    "unknownFields": {
+      "fields": {},
+      "fieldsDescending": {}
+    },
+    "memoizedSize": -1,
+    "memoizedHashCode": 596325405
+  },
+  {
+    "level_": 0,
+    "message_": "Not considering ANDROID_NDK_HOME because support was removed after deprecation period.",
+    "file_": "",
+    "tag_": "",
+    "diagnosticCode_": 0,
+    "memoizedIsInitialized": 1,
+    "unknownFields": {
+      "fields": {},
+      "fieldsDescending": {}
+    },
+    "memoizedSize": -1,
+    "memoizedHashCode": -1835827821
+  },
+  {
+    "level_": 0,
+    "message_": "sdkFolder is /Users/sabiha.durmaz/Library/Android/sdk",
+    "file_": "",
+    "tag_": "",
+    "diagnosticCode_": 0,
+    "memoizedIsInitialized": 1,
+    "unknownFields": {
+      "fields": {},
+      "fieldsDescending": {}
+    },
+    "memoizedSize": -1,
+    "memoizedHashCode": 1613458287
+  }
+]
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35_key.json b/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35_key.json
new file mode 100644
index 0000000..8d5dd20
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/cxx/ndk_locator_record_4l2a4b35_key.json
@@ -0,0 +1,9 @@
+{
+  "ndkVersionFromDsl": "23.1.7779620",
+  "sdkFolder": "/Users/sabiha.durmaz/Library/Android/sdk",
+  "sideBySideNdkFolderNames": [
+    "25.1.8937393",
+    "26.1.10909125",
+    "23.1.7779620"
+  ]
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/prefab_package_header_only/prefab_publication.json/debug b/node_modules/react-native-reanimated/android/build/intermediates/prefab_package_header_only/prefab_publication.json/debug
new file mode 100644
index 0000000..4be2127
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/prefab_package_header_only/prefab_publication.json/debug
@@ -0,0 +1,17 @@
+{
+  "installationFolder": "/Users/sabiha.durmaz/Projects/NEW_CLI/digitaldigitalCLI/node_modules/react-native-reanimated/android/build/intermediates/prefab_package/debug/prefab",
+  "gradlePath": ":react-native-reanimated",
+  "packageInfo": {
+    "packageName": "react-native-reanimated",
+    "packageSchemaVersion": 2,
+    "packageDependencies": [],
+    "modules": [
+      {
+        "moduleName": "reanimated",
+        "moduleHeaders": "/Users/sabiha.durmaz/Projects/NEW_CLI/digitaldigitalCLI/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated",
+        "moduleExportLibraries": [],
+        "abis": []
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/intermediates/prefab_package_header_only/prefab_publication.json/release b/node_modules/react-native-reanimated/android/build/intermediates/prefab_package_header_only/prefab_publication.json/release
new file mode 100644
index 0000000..b5d6ade
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/intermediates/prefab_package_header_only/prefab_publication.json/release
@@ -0,0 +1,17 @@
+{
+  "installationFolder": "/Users/sabiha.durmaz/Projects/NEW_CLI/digitaldigitalCLI/node_modules/react-native-reanimated/android/build/intermediates/prefab_package/release/prefab",
+  "gradlePath": ":react-native-reanimated",
+  "packageInfo": {
+    "packageName": "react-native-reanimated",
+    "packageSchemaVersion": 2,
+    "packageDependencies": [],
+    "modules": [
+      {
+        "moduleName": "reanimated",
+        "moduleHeaders": "/Users/sabiha.durmaz/Projects/NEW_CLI/digitaldigitalCLI/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated",
+        "moduleExportLibraries": [],
+        "abis": []
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AndroidLogger.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AndroidLogger.h
new file mode 100644
index 0000000..5e15ca7
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AndroidLogger.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <string>
+
+#include "LoggerInterface.h"
+
+namespace reanimated {
+
+class AndroidLogger : public LoggerInterface {
+ public:
+  void log(const char *str) override;
+  void log(const std::string &str) override;
+  void log(double d) override;
+  void log(int i) override;
+  void log(bool b) override;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AndroidUIScheduler.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AndroidUIScheduler.h
new file mode 100644
index 0000000..c476aa2
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AndroidUIScheduler.h
@@ -0,0 +1,43 @@
+#pragma once
+
+#include <fbjni/fbjni.h>
+#include <jni.h>
+#include <jsi/jsi.h>
+#include <react/jni/CxxModuleWrapper.h>
+#include <react/jni/JMessageQueueThread.h>
+
+#include <memory>
+
+#include "UIScheduler.h"
+
+namespace reanimated {
+
+using namespace facebook;
+
+class AndroidUIScheduler : public jni::HybridClass<AndroidUIScheduler> {
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/AndroidUIScheduler;";
+  static jni::local_ref<jhybriddata> initHybrid(
+      jni::alias_ref<jhybridobject> jThis);
+  static void registerNatives();
+
+  std::shared_ptr<UIScheduler> getUIScheduler() {
+    return uiScheduler_;
+  }
+
+  void scheduleTriggerOnUI();
+
+ private:
+  friend HybridBase;
+
+  void triggerUI();
+
+  jni::global_ref<AndroidUIScheduler::javaobject> javaPart_;
+  std::shared_ptr<UIScheduler> uiScheduler_;
+
+  explicit AndroidUIScheduler(
+      jni::alias_ref<AndroidUIScheduler::jhybridobject> jThis);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AnimatedSensorModule.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AnimatedSensorModule.h
new file mode 100644
index 0000000..0ec39d9
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AnimatedSensorModule.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include <jsi/jsi.h>
+#include <memory>
+#include <unordered_set>
+
+#include "PlatformDepMethodsHolder.h"
+#include "Shareables.h"
+#include "WorkletRuntime.h"
+
+namespace reanimated {
+
+using namespace facebook;
+
+enum SensorType {
+  ACCELEROMETER = 1,
+  GYROSCOPE = 2,
+  GRAVITY = 3,
+  MAGNETIC_FIELD = 4,
+  ROTATION_VECTOR = 5,
+};
+
+class AnimatedSensorModule {
+  std::unordered_set<int> sensorsIds_;
+  RegisterSensorFunction platformRegisterSensorFunction_;
+  UnregisterSensorFunction platformUnregisterSensorFunction_;
+
+ public:
+  AnimatedSensorModule(
+      const PlatformDepMethodsHolder &platformDepMethodsHolder);
+  ~AnimatedSensorModule();
+
+  jsi::Value registerSensor(
+      jsi::Runtime &rt,
+      const std::shared_ptr<WorkletRuntime> &uiWorkletRuntime,
+      const jsi::Value &sensorType,
+      const jsi::Value &interval,
+      const jsi::Value &iosReferenceFrame,
+      const jsi::Value &sensorDataContainer);
+  void unregisterSensor(const jsi::Value &sensorId);
+  void unregisterAllSensors();
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AsyncQueue.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AsyncQueue.h
new file mode 100644
index 0000000..4f175a4
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/AsyncQueue.h
@@ -0,0 +1,35 @@
+#pragma once
+
+#include <jsi/jsi.h>
+
+#include <atomic>
+#include <condition_variable>
+#include <memory>
+#include <queue>
+#include <string>
+#include <thread>
+#include <utility>
+#include <vector>
+
+namespace reanimated {
+
+struct AsyncQueueState {
+  std::atomic_bool running{true};
+  std::mutex mutex;
+  std::condition_variable cv;
+  std::queue<std::function<void()>> queue;
+};
+
+class AsyncQueue {
+ public:
+  explicit AsyncQueue(std::string name);
+
+  ~AsyncQueue();
+
+  void push(std::function<void()> &&job);
+
+ private:
+  const std::shared_ptr<AsyncQueueState> state_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/CollectionUtils.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/CollectionUtils.h
new file mode 100644
index 0000000..9bf9c03
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/CollectionUtils.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include <algorithm>
+
+namespace reanimated {
+namespace collection {
+
+template <class CollectionType, class ValueType>
+inline bool contains(const CollectionType &collection, const ValueType &value) {
+  return collection.find(value) != collection.end();
+}
+
+} // namespace collection
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/EventHandlerRegistry.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/EventHandlerRegistry.h
new file mode 100644
index 0000000..44e2036
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/EventHandlerRegistry.h
@@ -0,0 +1,51 @@
+#pragma once
+
+#include <jsi/jsi.h>
+
+#include <map>
+#include <memory>
+#include <mutex>
+#include <set>
+#include <string>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include "WorkletRuntime.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+class WorkletEventHandler;
+
+class EventHandlerRegistry {
+  std::map<
+      std::pair<int, std::string>,
+      std::unordered_map<uint64_t, std::shared_ptr<WorkletEventHandler>>>
+      eventMappingsWithTag;
+  std::map<
+      std::string,
+      std::unordered_map<uint64_t, std::shared_ptr<WorkletEventHandler>>>
+      eventMappingsWithoutTag;
+  std::map<uint64_t, std::shared_ptr<WorkletEventHandler>> eventHandlers;
+  std::mutex instanceMutex;
+
+ public:
+  void registerEventHandler(
+      const std::shared_ptr<WorkletEventHandler> &eventHandler);
+  void unregisterEventHandler(const uint64_t id);
+
+  void processEvent(
+      const std::shared_ptr<WorkletRuntime> &uiWorkletRuntime,
+      const double eventTimestamp,
+      const std::string &eventName,
+      const int emitterReactTag,
+      const jsi::Value &eventPayload);
+
+  bool isAnyHandlerWaitingForEvent(
+      const std::string &eventName,
+      const int emitterReactTag);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/FeaturesConfig.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/FeaturesConfig.h
new file mode 100644
index 0000000..c07e824
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/FeaturesConfig.h
@@ -0,0 +1,19 @@
+#pragma once
+#include <string>
+
+namespace reanimated {
+
+class FeaturesConfig {
+ public:
+  static inline bool isLayoutAnimationEnabled() {
+    return _isLayoutAnimationEnabled;
+  }
+  static inline void setLayoutAnimationEnabled(bool isLayoutAnimationEnabled) {
+    _isLayoutAnimationEnabled = isLayoutAnimationEnabled;
+  }
+
+ private:
+  static bool _isLayoutAnimationEnabled;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JNIHelper.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JNIHelper.h
new file mode 100644
index 0000000..4be3555
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JNIHelper.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include <fbjni/fbjni.h>
+#include <jsi/JSIDynamic.h>
+#include <jsi/jsi.h>
+#include <react/jni/CxxModuleWrapper.h>
+#include <react/jni/JMessageQueueThread.h>
+#include <react/jni/WritableNativeMap.h>
+#include <string>
+
+namespace reanimated {
+
+using namespace facebook::jni;
+using namespace facebook;
+using namespace react;
+
+struct JNIHelper {
+  struct PropsMap : jni::JavaClass<PropsMap, JMap<JString, JObject>> {
+    static constexpr auto kJavaDescriptor = "Ljava/util/HashMap;";
+
+    static local_ref<PropsMap> create();
+    void put(const std::string &key, jni::local_ref<JObject> object);
+  };
+
+  static jni::local_ref<PropsMap> ConvertToPropsMap(
+      jsi::Runtime &rt,
+      const jsi::Object &props);
+};
+
+}; // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSISerializer.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSISerializer.h
new file mode 100644
index 0000000..20ae796
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSISerializer.h
@@ -0,0 +1,45 @@
+#pragma once
+
+#include <jsi/jsi.h>
+#include <string>
+#include <vector>
+
+using namespace facebook;
+
+namespace {
+class JSISerializer {
+ public:
+  explicit JSISerializer(jsi::Runtime &rt);
+  std::string stringifyJSIValueRecursively(
+      const jsi::Value &value,
+      bool isTopLevel = false);
+
+ private:
+  std::string stringifyArray(const jsi::Array &arr);
+  std::string stringifyFunction(const jsi::Function &func);
+  std::string stringifyHostObject(jsi::HostObject &hostObject);
+  std::string stringifyObject(const jsi::Object &object);
+  std::string stringifyError(const jsi::Object &object);
+  std::string stringifySet(const jsi::Object &object);
+  std::string stringifyMap(const jsi::Object &object);
+  std::string stringifyWithName(const jsi::Object &object);
+  std::string stringifyWithToString(const jsi::Object &object);
+  std::string stringifyRecursiveType(const jsi::Object &object);
+
+  bool hasBeenVisited(const jsi::Object &object) {
+    return visitedNodes_.getPropertyAsFunction(rt_, "has")
+        .callWithThis(rt_, visitedNodes_, object)
+        .getBool();
+  }
+
+  void markAsVisited(const jsi::Object &object) {
+    visitedNodes_.getPropertyAsFunction(rt_, "add")
+        .callWithThis(rt_, visitedNodes_, object);
+  }
+
+  jsi::Runtime &rt_;
+  jsi::Object visitedNodes_;
+};
+} // namespace
+
+std::string stringifyJSIValue(jsi::Runtime &rt, const jsi::Value &value);
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSLogger.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSLogger.h
new file mode 100644
index 0000000..9ddfc7d
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSLogger.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "JSScheduler.h"
+
+#include <memory>
+#include <string>
+
+namespace reanimated {
+
+class JSLogger {
+ public:
+  explicit JSLogger(const std::shared_ptr<JSScheduler> &jsScheduler)
+      : jsScheduler_(jsScheduler) {}
+  void warnOnJS(const std::string &warning) const;
+
+ private:
+  const std::shared_ptr<JSScheduler> jsScheduler_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSScheduler.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSScheduler.h
new file mode 100644
index 0000000..f91217f
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/JSScheduler.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include <ReactCommon/CallInvoker.h>
+#include <jsi/jsi.h>
+
+#include <memory>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class JSScheduler {
+ public:
+  explicit JSScheduler(
+      jsi::Runtime &rnRuntime,
+      const std::shared_ptr<facebook::react::CallInvoker> &jsCallInvoker)
+      : rnRuntime_(rnRuntime), jsCallInvoker_(jsCallInvoker) {}
+  void scheduleOnJS(std::function<void(jsi::Runtime &rt)> job);
+
+ protected:
+  jsi::Runtime &rnRuntime_;
+  const std::shared_ptr<facebook::react::CallInvoker> jsCallInvoker_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimationType.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimationType.h
new file mode 100644
index 0000000..229558e
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimationType.h
@@ -0,0 +1,9 @@
+#pragma once
+
+typedef enum LayoutAnimationType {
+  ENTERING = 1,
+  EXITING = 2,
+  LAYOUT = 3,
+  SHARED_ELEMENT_TRANSITION = 4,
+  SHARED_ELEMENT_TRANSITION_PROGRESS = 5,
+} LayoutAnimationType;
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimations.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimations.h
new file mode 100644
index 0000000..053c894
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimations.h
@@ -0,0 +1,84 @@
+#pragma once
+
+#include <fbjni/fbjni.h>
+#include <jsi/jsi.h>
+#include <memory>
+#include <string>
+#include "JNIHelper.h"
+
+namespace reanimated {
+
+using namespace facebook::jni;
+using namespace facebook;
+
+class LayoutAnimations : public jni::HybridClass<LayoutAnimations> {
+  using AnimationStartingBlock =
+      std::function<void(int, int, alias_ref<JMap<jstring, jstring>>)>;
+  using HasAnimationBlock = std::function<bool(int, int)>;
+  using ShouldAnimateExitingBlock = std::function<bool(int, bool)>;
+#ifndef NDEBUG
+  using CheckDuplicateSharedTag = std::function<void(int, int)>;
+#endif
+  using ClearAnimationConfigBlock = std::function<void(int)>;
+  using CancelAnimationBlock = std::function<void(int)>;
+  using FindPrecedingViewTagForTransitionBlock = std::function<int(int)>;
+
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/layoutReanimation/LayoutAnimations;";
+  static jni::local_ref<jhybriddata> initHybrid(
+      jni::alias_ref<jhybridobject> jThis);
+  static void registerNatives();
+
+  void startAnimationForTag(
+      int tag,
+      int type,
+      alias_ref<JMap<jstring, jstring>> values);
+  bool hasAnimationForTag(int tag, int type);
+  bool shouldAnimateExiting(int tag, bool shouldAnimate);
+  bool isLayoutAnimationEnabled();
+
+  void setAnimationStartingBlock(AnimationStartingBlock animationStartingBlock);
+  void setHasAnimationBlock(HasAnimationBlock hasAnimationBlock);
+  void setShouldAnimateExitingBlock(
+      ShouldAnimateExitingBlock shouldAnimateExitingBlock);
+#ifndef NDEBUG
+  void setCheckDuplicateSharedTag(
+      CheckDuplicateSharedTag checkDuplicateSharedTag);
+  void checkDuplicateSharedTag(int viewTag, int screenTag);
+#endif
+  void setClearAnimationConfigBlock(
+      ClearAnimationConfigBlock clearAnimationConfigBlock);
+  void setCancelAnimationForTag(CancelAnimationBlock cancelAnimationBlock);
+  void setFindPrecedingViewTagForTransition(
+      FindPrecedingViewTagForTransitionBlock
+          findPrecedingViewTagForTransitionBlock);
+
+  void progressLayoutAnimation(
+      int tag,
+      const jni::local_ref<JNIHelper::PropsMap> &updates,
+      bool isSharedTransition);
+  void endLayoutAnimation(int tag, bool removeView);
+  void clearAnimationConfigForTag(int tag);
+  void cancelAnimationForTag(int tag);
+  int findPrecedingViewTagForTransition(int tag);
+
+ private:
+  friend HybridBase;
+  jni::global_ref<LayoutAnimations::javaobject> javaPart_;
+  AnimationStartingBlock animationStartingBlock_;
+  HasAnimationBlock hasAnimationBlock_;
+  ShouldAnimateExitingBlock shouldAnimateExitingBlock_;
+  ClearAnimationConfigBlock clearAnimationConfigBlock_;
+  CancelAnimationBlock cancelAnimationBlock_;
+  FindPrecedingViewTagForTransitionBlock
+      findPrecedingViewTagForTransitionBlock_;
+#ifndef NDEBUG
+  CheckDuplicateSharedTag checkDuplicateSharedTag_;
+#endif
+
+  explicit LayoutAnimations(
+      jni::alias_ref<LayoutAnimations::jhybridobject> jThis);
+};
+
+}; // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimationsManager.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimationsManager.h
new file mode 100644
index 0000000..db3de23
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/LayoutAnimationsManager.h
@@ -0,0 +1,83 @@
+#pragma once
+
+#include "JSLogger.h"
+#include "LayoutAnimationType.h"
+#include "Shareables.h"
+
+#include <jsi/jsi.h>
+#include <stdio.h>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
+namespace reanimated {
+
+using namespace facebook;
+
+struct LayoutAnimationConfig {
+  int tag;
+  LayoutAnimationType type;
+  std::shared_ptr<Shareable> config;
+};
+
+class LayoutAnimationsManager {
+ public:
+  explicit LayoutAnimationsManager(const std::shared_ptr<JSLogger> &jsLogger)
+      : jsLogger_(jsLogger) {}
+  void configureAnimation(
+      const int tag,
+      const LayoutAnimationType type,
+      const std::string &sharedTransitionTag,
+      const std::shared_ptr<Shareable> &config);
+  void configureAnimationBatch(
+      const std::vector<LayoutAnimationConfig> &layoutAnimationsBatch);
+  void setShouldAnimateExiting(const int tag, const bool value);
+  bool shouldAnimateExiting(const int tag, const bool shouldAnimate);
+  bool hasLayoutAnimation(const int tag, const LayoutAnimationType type);
+  void startLayoutAnimation(
+      jsi::Runtime &rt,
+      const int tag,
+      const LayoutAnimationType type,
+      const jsi::Object &values);
+  void clearLayoutAnimationConfig(const int tag);
+  void cancelLayoutAnimation(jsi::Runtime &rt, const int tag) const;
+  int findPrecedingViewTagForTransition(const int tag);
+#ifndef NDEBUG
+  std::string getScreenSharedTagPairString(
+      const int screenTag,
+      const std::string &sharedTag) const;
+  void checkDuplicateSharedTag(const int viewTag, const int screenTag);
+#endif
+
+ private:
+  std::unordered_map<int, std::shared_ptr<Shareable>> &getConfigsForType(
+      const LayoutAnimationType type);
+
+  std::shared_ptr<JSLogger> jsLogger_;
+#ifndef NDEBUG
+  // This set's function is to detect duplicate sharedTags on a single screen
+  // it contains strings in form: "reactScreenTag:sharedTag"
+  std::unordered_set<std::string> screenSharedTagSet_;
+  // And this map is to remove collected pairs on SET removal
+  std::unordered_map<int, std::string> viewsScreenSharedTagMap_;
+#endif
+
+  std::unordered_map<int, std::shared_ptr<Shareable>> enteringAnimations_;
+  std::unordered_map<int, std::shared_ptr<Shareable>> exitingAnimations_;
+  std::unordered_map<int, std::shared_ptr<Shareable>> layoutAnimations_;
+  std::unordered_map<int, std::shared_ptr<Shareable>>
+      sharedTransitionAnimations_;
+  std::unordered_set<int> ignoreProgressAnimationForTag_;
+  std::unordered_map<std::string, std::vector<int>> sharedTransitionGroups_;
+  std::unordered_map<int, std::string> viewTagToSharedTag_;
+  std::unordered_map<int, bool> shouldAnimateExitingForTag_;
+  mutable std::mutex
+      animationsMutex_; // Protects `enteringAnimations_`, `exitingAnimations_`,
+  // `layoutAnimations_`, `viewSharedValues_` and `shouldAnimateExitingForTag_`.
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeProxy.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeProxy.h
new file mode 100644
index 0000000..90a7d9c
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeProxy.h
@@ -0,0 +1,274 @@
+#pragma once
+
+#ifdef RCT_NEW_ARCH_ENABLED
+#include <react/fabric/JFabricUIManager.h>
+#include <react/renderer/scheduler/Scheduler.h>
+#endif
+
+#include <ReactCommon/CallInvokerHolder.h>
+#include <fbjni/fbjni.h>
+#include <jsi/jsi.h>
+#include <react/jni/CxxModuleWrapper.h>
+#include <react/jni/JMessageQueueThread.h>
+#include <react/jni/JavaScriptExecutorHolder.h>
+#include <react/jni/WritableNativeMap.h>
+
+#include <memory>
+#include <string>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include "AndroidUIScheduler.h"
+#include "JNIHelper.h"
+#include "LayoutAnimations.h"
+#include "NativeReanimatedModule.h"
+#include "UIScheduler.h"
+
+namespace reanimated {
+
+using namespace facebook;
+using namespace facebook::jni;
+
+class AnimationFrameCallback : public HybridClass<AnimationFrameCallback> {
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/nativeProxy/AnimationFrameCallback;";
+
+  void onAnimationFrame(double timestampMs) {
+    callback_(timestampMs);
+  }
+
+  static void registerNatives() {
+    javaClassStatic()->registerNatives({
+        makeNativeMethod(
+            "onAnimationFrame", AnimationFrameCallback::onAnimationFrame),
+    });
+  }
+
+ private:
+  friend HybridBase;
+
+  explicit AnimationFrameCallback(std::function<void(double)> callback)
+      : callback_(std::move(callback)) {}
+
+  std::function<void(double)> callback_;
+};
+
+class EventHandler : public HybridClass<EventHandler> {
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/nativeProxy/EventHandler;";
+
+  void receiveEvent(
+      jni::alias_ref<JString> eventKey,
+      jint emitterReactTag,
+      jni::alias_ref<react::WritableMap> event) {
+    handler_(eventKey, emitterReactTag, event);
+  }
+
+  static void registerNatives() {
+    javaClassStatic()->registerNatives({
+        makeNativeMethod("receiveEvent", EventHandler::receiveEvent),
+    });
+  }
+
+ private:
+  friend HybridBase;
+
+  explicit EventHandler(std::function<void(
+                            jni::alias_ref<JString>,
+                            jint emitterReactTag,
+                            jni::alias_ref<react::WritableMap>)> handler)
+      : handler_(std::move(handler)) {}
+
+  std::function<
+      void(jni::alias_ref<JString>, jint, jni::alias_ref<react::WritableMap>)>
+      handler_;
+};
+
+class SensorSetter : public HybridClass<SensorSetter> {
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/nativeProxy/SensorSetter;";
+
+  void sensorSetter(jni::alias_ref<JArrayFloat> value, int orientationDegrees) {
+    size_t size = value->size();
+    auto elements = value->getRegion(0, size);
+    double array[7];
+    for (size_t i = 0; i < size; i++) {
+      array[i] = elements[i];
+    }
+    callback_(array, orientationDegrees);
+  }
+
+  static void registerNatives() {
+    javaClassStatic()->registerNatives({
+        makeNativeMethod("sensorSetter", SensorSetter::sensorSetter),
+    });
+  }
+
+ private:
+  friend HybridBase;
+
+  explicit SensorSetter(std::function<void(double[], int)> callback)
+      : callback_(std::move(callback)) {}
+
+  std::function<void(double[], int)> callback_;
+};
+
+class KeyboardWorkletWrapper : public HybridClass<KeyboardWorkletWrapper> {
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/keyboard/KeyboardWorkletWrapper;";
+
+  void invoke(int keyboardState, int height) {
+    callback_(keyboardState, height);
+  }
+
+  static void registerNatives() {
+    javaClassStatic()->registerNatives({
+        makeNativeMethod("invoke", KeyboardWorkletWrapper::invoke),
+    });
+  }
+
+ private:
+  friend HybridBase;
+
+  explicit KeyboardWorkletWrapper(std::function<void(int, int)> callback)
+      : callback_(std::move(callback)) {}
+
+  std::function<void(int, int)> callback_;
+};
+
+class NativeProxy : public jni::HybridClass<NativeProxy> {
+ public:
+  static auto constexpr kJavaDescriptor =
+      "Lcom/swmansion/reanimated/NativeProxy;";
+  static jni::local_ref<jhybriddata> initHybrid(
+      jni::alias_ref<jhybridobject> jThis,
+      jlong jsContext,
+      jni::alias_ref<facebook::react::CallInvokerHolder::javaobject>
+          jsCallInvokerHolder,
+      jni::alias_ref<AndroidUIScheduler::javaobject> androidUiScheduler,
+      jni::alias_ref<LayoutAnimations::javaobject> layoutAnimations,
+      jni::alias_ref<JavaMessageQueueThread::javaobject> messageQueueThread,
+#ifdef RCT_NEW_ARCH_ENABLED
+      jni::alias_ref<facebook::react::JFabricUIManager::javaobject>
+          fabricUIManager,
+#endif
+      const std::string &valueUnpackerCode);
+  static void registerNatives();
+
+  ~NativeProxy();
+
+ private:
+  friend HybridBase;
+  jni::global_ref<NativeProxy::javaobject> javaPart_;
+  jsi::Runtime *rnRuntime_;
+  std::shared_ptr<NativeReanimatedModule> nativeReanimatedModule_;
+  jni::global_ref<LayoutAnimations::javaobject> layoutAnimations_;
+#ifndef NDEBUG
+  void checkJavaVersion(jsi::Runtime &);
+  void injectCppVersion();
+#endif // NDEBUG
+#ifdef RCT_NEW_ARCH_ENABLED
+  // removed temporarily, event listener mechanism needs to be fixed on RN side
+  // std::shared_ptr<facebook::react::Scheduler> reactScheduler_;
+  // std::shared_ptr<EventListener> eventListener_;
+#endif
+  void installJSIBindings();
+#ifdef RCT_NEW_ARCH_ENABLED
+  void synchronouslyUpdateUIProps(
+      jsi::Runtime &rt,
+      Tag viewTag,
+      const jsi::Object &props);
+#endif
+  PlatformDepMethodsHolder getPlatformDependentMethods();
+  void setupLayoutAnimations();
+
+  double getAnimationTimestamp();
+  bool isAnyHandlerWaitingForEvent(
+      const std::string &eventName,
+      const int emitterReactTag);
+  void performOperations();
+  bool getIsReducedMotion();
+  void requestRender(std::function<void(double)> onRender, jsi::Runtime &rt);
+  void registerEventHandler();
+  void maybeFlushUIUpdatesQueue();
+  void setGestureState(int handlerTag, int newState);
+  int registerSensor(
+      int sensorType,
+      int interval,
+      int iosReferenceFrame,
+      std::function<void(double[], int)> setter);
+  void unregisterSensor(int sensorId);
+  int subscribeForKeyboardEvents(
+      std::function<void(int, int)> callback,
+      bool isStatusBarTranslucent);
+  void unsubscribeFromKeyboardEvents(int listenerId);
+#ifdef RCT_NEW_ARCH_ENABLED
+  // nothing
+#else
+  jsi::Value
+  obtainProp(jsi::Runtime &rt, const int viewTag, const jsi::String &propName);
+  void configureProps(
+      jsi::Runtime &rt,
+      const jsi::Value &uiProps,
+      const jsi::Value &nativeProps);
+  void updateProps(jsi::Runtime &rt, const jsi::Value &operations);
+  void scrollTo(int viewTag, double x, double y, bool animated);
+  void dispatchCommand(
+      jsi::Runtime &rt,
+      const int viewTag,
+      const jsi::Value &commandNameValue,
+      const jsi::Value &argsValue);
+  std::vector<std::pair<std::string, double>> measure(int viewTag);
+#endif
+  void handleEvent(
+      jni::alias_ref<JString> eventName,
+      jint emitterReactTag,
+      jni::alias_ref<react::WritableMap> event);
+
+  void progressLayoutAnimation(
+      jsi::Runtime &rt,
+      int tag,
+      const jsi::Object &newProps,
+      bool isSharedTransition);
+
+  /***
+   * Wraps a method of `NativeProxy` in a function object capturing `this`
+   * @tparam TReturn return type of passed method
+   * @tparam TParams paramater types of passed method
+   * @param methodPtr pointer to method to be wrapped
+   * @return a function object with the same signature as the method, calling
+   * that method on `this`
+   */
+  template <class TReturn, class... TParams>
+  std::function<TReturn(TParams...)> bindThis(
+      TReturn (NativeProxy::*methodPtr)(TParams...)) {
+    return [this, methodPtr](TParams &&...args) {
+      return (this->*methodPtr)(std::forward<TParams>(args)...);
+    };
+  }
+
+  template <class Signature>
+  JMethod<Signature> getJniMethod(std::string const &methodName) {
+    return javaPart_->getClass()->getMethod<Signature>(methodName.c_str());
+  }
+
+  explicit NativeProxy(
+      jni::alias_ref<NativeProxy::jhybridobject> jThis,
+      jsi::Runtime *rnRuntime,
+      const std::shared_ptr<facebook::react::CallInvoker> &jsCallInvoker,
+      const std::shared_ptr<UIScheduler> &uiScheduler,
+      jni::global_ref<LayoutAnimations::javaobject> layoutAnimations,
+      jni::alias_ref<JavaMessageQueueThread::javaobject> messageQueueThread,
+#ifdef RCT_NEW_ARCH_ENABLED
+      jni::alias_ref<facebook::react::JFabricUIManager::javaobject>
+          fabricUIManager,
+#endif
+      const std::string &valueUnpackerCode);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeReanimatedModule.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeReanimatedModule.h
new file mode 100644
index 0000000..9f8c32d
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeReanimatedModule.h
@@ -0,0 +1,222 @@
+#pragma once
+
+#ifdef RCT_NEW_ARCH_ENABLED
+#include <react/renderer/uimanager/UIManager.h>
+#endif
+
+#include <memory>
+#include <string>
+#include <unordered_set>
+#include <utility>
+#include <vector>
+
+#include "AnimatedSensorModule.h"
+#include "EventHandlerRegistry.h"
+#include "JSScheduler.h"
+#include "LayoutAnimationsManager.h"
+#include "NativeReanimatedModuleSpec.h"
+#include "PlatformDepMethodsHolder.h"
+#include "SingleInstanceChecker.h"
+#include "UIScheduler.h"
+
+#ifdef RCT_NEW_ARCH_ENABLED
+#include "PropsRegistry.h"
+#include "ReanimatedCommitHook.h"
+#if REACT_NATIVE_MINOR_VERSION >= 73
+#include "ReanimatedMountHook.h"
+#endif
+#endif
+
+namespace reanimated {
+
+class NativeReanimatedModule : public NativeReanimatedModuleSpec {
+ public:
+  NativeReanimatedModule(
+      jsi::Runtime &rnRuntime,
+      const std::shared_ptr<CallInvoker> &jsInvoker,
+      const std::shared_ptr<MessageQueueThread> &jsQueue,
+      const std::shared_ptr<UIScheduler> &uiScheduler,
+      const PlatformDepMethodsHolder &platformDepMethodsHolder,
+      const std::string &valueUnpackerCode);
+
+  ~NativeReanimatedModule();
+
+  jsi::Value makeShareableClone(
+      jsi::Runtime &rt,
+      const jsi::Value &value,
+      const jsi::Value &shouldRetainRemote) override;
+
+  void scheduleOnUI(jsi::Runtime &rt, const jsi::Value &worklet) override;
+  jsi::Value executeOnUIRuntimeSync(jsi::Runtime &rt, const jsi::Value &worklet)
+      override;
+
+  jsi::Value createWorkletRuntime(
+      jsi::Runtime &rt,
+      const jsi::Value &name,
+      const jsi::Value &initializer) override;
+  jsi::Value scheduleOnRuntime(
+      jsi::Runtime &rt,
+      const jsi::Value &workletRuntimeValue,
+      const jsi::Value &shareableWorkletValue) override;
+
+  jsi::Value registerEventHandler(
+      jsi::Runtime &rt,
+      const jsi::Value &worklet,
+      const jsi::Value &eventName,
+      const jsi::Value &emitterReactTag) override;
+  void unregisterEventHandler(
+      jsi::Runtime &rt,
+      const jsi::Value &registrationId) override;
+
+  jsi::Value getViewProp(
+      jsi::Runtime &rt,
+      const jsi::Value &viewTag,
+      const jsi::Value &propName,
+      const jsi::Value &callback) override;
+
+  jsi::Value enableLayoutAnimations(jsi::Runtime &rt, const jsi::Value &config)
+      override;
+  jsi::Value configureProps(
+      jsi::Runtime &rt,
+      const jsi::Value &uiProps,
+      const jsi::Value &nativeProps) override;
+  jsi::Value configureLayoutAnimation(
+      jsi::Runtime &rt,
+      const jsi::Value &viewTag,
+      const jsi::Value &type,
+      const jsi::Value &sharedTransitionTag,
+      const jsi::Value &config) override;
+  jsi::Value configureLayoutAnimationBatch(
+      jsi::Runtime &rt,
+      const jsi::Value &layoutAnimationsBatch) override;
+  void setShouldAnimateExiting(
+      jsi::Runtime &rt,
+      const jsi::Value &viewTag,
+      const jsi::Value &shouldAnimate) override;
+
+  void onRender(double timestampMs);
+
+  bool isAnyHandlerWaitingForEvent(
+      const std::string &eventName,
+      const int emitterReactTag);
+
+  void maybeRequestRender();
+
+  bool handleEvent(
+      const std::string &eventName,
+      const int emitterReactTag,
+      const jsi::Value &payload,
+      double currentTime);
+
+  inline std::shared_ptr<JSLogger> getJSLogger() const {
+    return jsLogger_;
+  }
+
+#ifdef RCT_NEW_ARCH_ENABLED
+  bool handleRawEvent(const RawEvent &rawEvent, double currentTime);
+
+  void updateProps(jsi::Runtime &rt, const jsi::Value &operations);
+
+  void removeFromPropsRegistry(jsi::Runtime &rt, const jsi::Value &viewTags);
+
+  void performOperations();
+
+  void dispatchCommand(
+      jsi::Runtime &rt,
+      const jsi::Value &shadowNodeValue,
+      const jsi::Value &commandNameValue,
+      const jsi::Value &argsValue);
+
+  jsi::Value measure(jsi::Runtime &rt, const jsi::Value &shadowNodeValue);
+
+  void initializeFabric(const std::shared_ptr<UIManager> &uiManager);
+#endif
+
+  jsi::Value registerSensor(
+      jsi::Runtime &rt,
+      const jsi::Value &sensorType,
+      const jsi::Value &interval,
+      const jsi::Value &iosReferenceFrame,
+      const jsi::Value &sensorDataContainer) override;
+  void unregisterSensor(jsi::Runtime &rt, const jsi::Value &sensorId) override;
+
+  void cleanupSensors();
+
+  jsi::Value subscribeForKeyboardEvents(
+      jsi::Runtime &rt,
+      const jsi::Value &keyboardEventContainer,
+      const jsi::Value &isStatusBarTranslucent) override;
+  void unsubscribeFromKeyboardEvents(
+      jsi::Runtime &rt,
+      const jsi::Value &listenerId) override;
+
+  inline LayoutAnimationsManager &layoutAnimationsManager() {
+    return layoutAnimationsManager_;
+  }
+
+  inline jsi::Runtime &getUIRuntime() {
+    return uiWorkletRuntime_->getJSIRuntime();
+  }
+
+ private:
+  void requestAnimationFrame(jsi::Runtime &rt, const jsi::Value &callback);
+
+#ifdef RCT_NEW_ARCH_ENABLED
+  bool isThereAnyLayoutProp(jsi::Runtime &rt, const jsi::Object &props);
+  jsi::Value filterNonAnimatableProps(
+      jsi::Runtime &rt,
+      const jsi::Value &props);
+#endif // RCT_NEW_ARCH_ENABLED
+
+  const std::shared_ptr<MessageQueueThread> jsQueue_;
+  const std::shared_ptr<JSScheduler> jsScheduler_;
+  const std::shared_ptr<UIScheduler> uiScheduler_;
+  std::shared_ptr<WorkletRuntime> uiWorkletRuntime_;
+  std::string valueUnpackerCode_;
+
+  std::unique_ptr<EventHandlerRegistry> eventHandlerRegistry_;
+  const RequestRenderFunction requestRender_;
+  std::vector<std::shared_ptr<jsi::Value>> frameCallbacks_;
+  volatile bool renderRequested_{false};
+  const std::function<void(const double)> onRenderCallback_;
+  AnimatedSensorModule animatedSensorModule_;
+  const std::shared_ptr<JSLogger> jsLogger_;
+  LayoutAnimationsManager layoutAnimationsManager_;
+
+#ifdef RCT_NEW_ARCH_ENABLED
+  const SynchronouslyUpdateUIPropsFunction synchronouslyUpdateUIPropsFunction_;
+
+  std::unordered_set<std::string> nativePropNames_; // filled by configureProps
+  std::unordered_set<std::string>
+      animatablePropNames_; // filled by configureProps
+  std::shared_ptr<UIManager> uiManager_;
+
+  // After app reload, surfaceId on iOS is still 1 but on Android it's 11.
+  // We can store surfaceId of the most recent ShadowNode as a workaround.
+  SurfaceId surfaceId_ = -1;
+
+  std::vector<std::pair<ShadowNode::Shared, std::unique_ptr<jsi::Value>>>
+      operationsInBatch_; // TODO: refactor std::pair to custom struct
+
+  std::shared_ptr<PropsRegistry> propsRegistry_;
+  std::shared_ptr<ReanimatedCommitHook> commitHook_;
+#if REACT_NATIVE_MINOR_VERSION >= 73
+  std::shared_ptr<ReanimatedMountHook> mountHook_;
+#endif
+
+  std::vector<Tag> tagsToRemove_; // from `propsRegistry_`
+#else
+  const ObtainPropFunction obtainPropFunction_;
+  const ConfigurePropsFunction configurePropsPlatformFunction_;
+  const UpdatePropsFunction updatePropsFunction_;
+#endif
+
+  const KeyboardEventSubscribeFunction subscribeForKeyboardEventsFunction_;
+  const KeyboardEventUnsubscribeFunction unsubscribeFromKeyboardEventsFunction_;
+
+#ifndef NDEBUG
+  SingleInstanceChecker<NativeReanimatedModule> singleInstanceChecker_;
+#endif
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeReanimatedModuleSpec.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeReanimatedModuleSpec.h
new file mode 100644
index 0000000..42a7c7f
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/NativeReanimatedModuleSpec.h
@@ -0,0 +1,112 @@
+#pragma once
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#ifdef ANDROID
+#include "TurboModule.h"
+#else
+#include <ReactCommon/TurboModule.h>
+#endif
+
+#include <ReactCommon/CallInvoker.h>
+
+using namespace facebook;
+using namespace react;
+
+namespace reanimated {
+
+class JSI_EXPORT NativeReanimatedModuleSpec : public TurboModule {
+ protected:
+  explicit NativeReanimatedModuleSpec(
+      const std::shared_ptr<CallInvoker> &jsInvoker);
+
+ public:
+  // SharedValue
+  virtual jsi::Value makeShareableClone(
+      jsi::Runtime &rt,
+      const jsi::Value &value,
+      const jsi::Value &shouldRetainRemote) = 0;
+
+  // Scheduling
+  virtual void scheduleOnUI(jsi::Runtime &rt, const jsi::Value &worklet) = 0;
+  virtual jsi::Value executeOnUIRuntimeSync(
+      jsi::Runtime &rt,
+      const jsi::Value &worklet) = 0;
+
+  // Worklet runtime
+  virtual jsi::Value createWorkletRuntime(
+      jsi::Runtime &rt,
+      const jsi::Value &name,
+      const jsi::Value &initializer) = 0;
+  virtual jsi::Value scheduleOnRuntime(
+      jsi::Runtime &rt,
+      const jsi::Value &workletRuntimeValue,
+      const jsi::Value &shareableWorkletValue) = 0;
+
+  // events
+  virtual jsi::Value registerEventHandler(
+      jsi::Runtime &rt,
+      const jsi::Value &worklet,
+      const jsi::Value &eventName,
+      const jsi::Value &emitterReactTag) = 0;
+  virtual void unregisterEventHandler(
+      jsi::Runtime &rt,
+      const jsi::Value &registrationId) = 0;
+
+  // views
+  virtual jsi::Value getViewProp(
+      jsi::Runtime &rt,
+      const jsi::Value &viewTag,
+      const jsi::Value &propName,
+      const jsi::Value &callback) = 0;
+
+  // sensors
+  virtual jsi::Value registerSensor(
+      jsi::Runtime &rt,
+      const jsi::Value &sensorType,
+      const jsi::Value &interval,
+      const jsi::Value &iosReferenceFrame,
+      const jsi::Value &sensorDataContainer) = 0;
+  virtual void unregisterSensor(
+      jsi::Runtime &rt,
+      const jsi::Value &sensorId) = 0;
+
+  // keyboard
+  virtual jsi::Value subscribeForKeyboardEvents(
+      jsi::Runtime &rt,
+      const jsi::Value &keyboardEventContainer,
+      const jsi::Value &isStatusBarTranslucent) = 0;
+  virtual void unsubscribeFromKeyboardEvents(
+      jsi::Runtime &rt,
+      const jsi::Value &listenerId) = 0;
+
+  // other
+  virtual jsi::Value enableLayoutAnimations(
+      jsi::Runtime &rt,
+      const jsi::Value &config) = 0;
+  virtual jsi::Value configureProps(
+      jsi::Runtime &rt,
+      const jsi::Value &uiProps,
+      const jsi::Value &nativeProps) = 0;
+
+  // layout animations
+  virtual jsi::Value configureLayoutAnimation(
+      jsi::Runtime &rt,
+      const jsi::Value &viewTag,
+      const jsi::Value &type,
+      const jsi::Value &sharedTransitionTag,
+      const jsi::Value &config) = 0;
+
+  virtual jsi::Value configureLayoutAnimationBatch(
+      jsi::Runtime &rt,
+      const jsi::Value &layoutAnimationsBatch) = 0;
+
+  virtual void setShouldAnimateExiting(
+      jsi::Runtime &rt,
+      const jsi::Value &viewTag,
+      const jsi::Value &shouldAnimate) = 0;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/PlatformDepMethodsHolder.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/PlatformDepMethodsHolder.h
new file mode 100644
index 0000000..43306f2
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/PlatformDepMethodsHolder.h
@@ -0,0 +1,98 @@
+#pragma once
+
+#include <jsi/jsi.h>
+
+#ifdef RCT_NEW_ARCH_ENABLED
+#include <react/renderer/core/ReactPrimitives.h>
+#endif
+
+#include <string>
+#include <utility>
+#include <vector>
+
+using namespace facebook;
+
+#ifdef RCT_NEW_ARCH_ENABLED
+using namespace react;
+#endif
+
+namespace reanimated {
+
+#ifdef RCT_NEW_ARCH_ENABLED
+
+using SynchronouslyUpdateUIPropsFunction =
+    std::function<void(jsi::Runtime &rt, Tag tag, const jsi::Object &props)>;
+using UpdatePropsFunction =
+    std::function<void(jsi::Runtime &rt, const jsi::Value &operations)>;
+using RemoveFromPropsRegistryFunction =
+    std::function<void(jsi::Runtime &rt, const jsi::Value &viewTags)>;
+using DispatchCommandFunction = std::function<void(
+    jsi::Runtime &rt,
+    const jsi::Value &shadowNodeValue,
+    const jsi::Value &commandNameValue,
+    const jsi::Value &argsValue)>;
+using MeasureFunction = std::function<
+    jsi::Value(jsi::Runtime &rt, const jsi::Value &shadowNodeValue)>;
+
+#else
+
+using UpdatePropsFunction =
+    std::function<void(jsi::Runtime &rt, const jsi::Value &operations)>;
+using ScrollToFunction = std::function<void(int, double, double, bool)>;
+using DispatchCommandFunction = std::function<void(
+    jsi::Runtime &rt,
+    const int viewTag,
+    const jsi::Value &commandNameValue,
+    const jsi::Value &argsValue)>;
+using MeasureFunction =
+    std::function<std::vector<std::pair<std::string, double>>(int)>;
+
+#endif // RCT_NEW_ARCH_ENABLED
+
+using RequestRenderFunction =
+    std::function<void(std::function<void(const double)>, jsi::Runtime &)>;
+using ObtainPropFunction =
+    std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)>;
+using GetAnimationTimestampFunction = std::function<double(void)>;
+
+using ProgressLayoutAnimationFunction =
+    std::function<void(jsi::Runtime &, int, jsi::Object, bool)>;
+using EndLayoutAnimationFunction = std::function<void(int, bool)>;
+
+using RegisterSensorFunction =
+    std::function<int(int, int, int, std::function<void(double[], int)>)>;
+using UnregisterSensorFunction = std::function<void(int)>;
+using SetGestureStateFunction = std::function<void(int, int)>;
+using ConfigurePropsFunction = std::function<void(
+    jsi::Runtime &rt,
+    const jsi::Value &uiProps,
+    const jsi::Value &nativeProps)>;
+using KeyboardEventSubscribeFunction =
+    std::function<int(std::function<void(int, int)>, bool)>;
+using KeyboardEventUnsubscribeFunction = std::function<void(int)>;
+using MaybeFlushUIUpdatesQueueFunction = std::function<void()>;
+
+struct PlatformDepMethodsHolder {
+  RequestRenderFunction requestRender;
+#ifdef RCT_NEW_ARCH_ENABLED
+  SynchronouslyUpdateUIPropsFunction synchronouslyUpdateUIPropsFunction;
+#else
+  UpdatePropsFunction updatePropsFunction;
+  ScrollToFunction scrollToFunction;
+  DispatchCommandFunction dispatchCommandFunction;
+  MeasureFunction measureFunction;
+  ConfigurePropsFunction configurePropsFunction;
+  ObtainPropFunction obtainPropFunction;
+#endif
+  GetAnimationTimestampFunction getAnimationTimestamp;
+  ProgressLayoutAnimationFunction progressLayoutAnimation;
+  EndLayoutAnimationFunction endLayoutAnimation;
+  RegisterSensorFunction registerSensor;
+  UnregisterSensorFunction unregisterSensor;
+  SetGestureStateFunction setGestureStateFunction;
+  KeyboardEventSubscribeFunction subscribeForKeyboardEvents;
+  KeyboardEventUnsubscribeFunction unsubscribeFromKeyboardEvents;
+  MaybeFlushUIUpdatesQueueFunction maybeFlushUIUpdatesQueueFunction;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/PropsRegistry.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/PropsRegistry.h
new file mode 100644
index 0000000..2cbaab3
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/PropsRegistry.h
@@ -0,0 +1,58 @@
+#pragma once
+#ifdef RCT_NEW_ARCH_ENABLED
+
+#include <react/renderer/components/root/RootShadowNode.h>
+#include <react/renderer/core/ShadowNode.h>
+
+#include <unordered_map>
+#include <utility>
+
+using namespace facebook;
+using namespace react;
+
+namespace reanimated {
+
+class PropsRegistry {
+ public:
+  std::lock_guard<std::mutex> createLock() const;
+  // returns a lock you need to hold when calling any of the methods below
+
+  void update(const ShadowNode::Shared &shadowNode, folly::dynamic &&props);
+
+  void for_each(std::function<void(
+                    const ShadowNodeFamily &family,
+                    const folly::dynamic &props)> callback) const;
+
+  void remove(const Tag tag);
+
+  void pleaseSkipReanimatedCommit() {
+    shouldReanimatedSkipCommit_ = true;
+  }
+
+  bool shouldReanimatedSkipCommit() {
+#if REACT_NATIVE_MINOR_VERSION >= 73
+    // In RN 0.73+ we have a mount hook that will properly unset this flag
+    // after a non-Reanimated commit.
+    return shouldReanimatedSkipCommit_;
+#else
+    return shouldReanimatedSkipCommit_.exchange(false);
+#endif
+  }
+
+#if REACT_NATIVE_MINOR_VERSION >= 73
+  void resetReanimatedSkipCommitFlag() {
+    shouldReanimatedSkipCommit_ = false;
+  }
+#endif
+
+ private:
+  std::unordered_map<Tag, std::pair<ShadowNode::Shared, folly::dynamic>> map_;
+
+  mutable std::mutex mutex_; // Protects `map_`.
+
+  std::atomic<bool> shouldReanimatedSkipCommit_;
+};
+
+} // namespace reanimated
+
+#endif // RCT_NEW_ARCH_ENABLED
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/RNRuntimeDecorator.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/RNRuntimeDecorator.h
new file mode 100644
index 0000000..dba2e2b
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/RNRuntimeDecorator.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <jsi/jsi.h>
+
+#include <memory>
+
+#include "NativeReanimatedModule.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+class RNRuntimeDecorator {
+ public:
+  static void decorate(
+      jsi::Runtime &rnRuntime,
+      const std::shared_ptr<NativeReanimatedModule> &nativeReanimatedModule,
+      const bool isReducedMotion);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedCommitHook.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedCommitHook.h
new file mode 100644
index 0000000..22ebd3c
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedCommitHook.h
@@ -0,0 +1,51 @@
+#pragma once
+#ifdef RCT_NEW_ARCH_ENABLED
+
+#include <react/renderer/uimanager/UIManagerCommitHook.h>
+
+#include <memory>
+
+#include "PropsRegistry.h"
+
+using namespace facebook::react;
+
+namespace reanimated {
+
+class ReanimatedCommitHook : public UIManagerCommitHook {
+ public:
+  ReanimatedCommitHook(
+      const std::shared_ptr<PropsRegistry> &propsRegistry,
+      const std::shared_ptr<UIManager> &uiManager);
+
+  ~ReanimatedCommitHook() noexcept override;
+
+#if REACT_NATIVE_MINOR_VERSION >= 73
+  void commitHookWasRegistered(UIManager const &) noexcept override {}
+
+  void commitHookWasUnregistered(UIManager const &) noexcept override {}
+
+  RootShadowNode::Unshared shadowTreeWillCommit(
+      ShadowTree const &shadowTree,
+      RootShadowNode::Shared const &oldRootShadowNode,
+      RootShadowNode::Unshared const &newRootShadowNode) noexcept override;
+#else
+  void commitHookWasRegistered(UIManager const &) const noexcept override {}
+
+  void commitHookWasUnregistered(UIManager const &) const noexcept override {}
+
+  RootShadowNode::Unshared shadowTreeWillCommit(
+      ShadowTree const &shadowTree,
+      RootShadowNode::Shared const &oldRootShadowNode,
+      RootShadowNode::Unshared const &newRootShadowNode)
+      const noexcept override;
+#endif
+
+ private:
+  std::shared_ptr<PropsRegistry> propsRegistry_;
+
+  std::shared_ptr<UIManager> uiManager_;
+};
+
+} // namespace reanimated
+
+#endif // RCT_NEW_ARCH_ENABLED
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedCommitMarker.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedCommitMarker.h
new file mode 100644
index 0000000..68e3ca9
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedCommitMarker.h
@@ -0,0 +1,23 @@
+#pragma once
+#ifdef RCT_NEW_ARCH_ENABLED
+
+namespace reanimated {
+
+// This class is used to mark shadow tree commit as coming from Reanimated.
+// During the life of this object, isReanimatedCommit() will return true, false
+// otherwise. isReanimatedCommit() value change is restricted to the thread that
+// created the object.
+class ReanimatedCommitMarker {
+ public:
+  ReanimatedCommitMarker();
+  ~ReanimatedCommitMarker();
+
+  static bool isReanimatedCommit();
+
+ private:
+  static thread_local bool reanimatedCommitFlag_;
+};
+
+} // namespace reanimated
+
+#endif // RCT_NEW_ARCH_ENABLED
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedHermesRuntime.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedHermesRuntime.h
new file mode 100644
index 0000000..3b9b7cb
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedHermesRuntime.h
@@ -0,0 +1,149 @@
+#pragma once
+
+// JS_RUNTIME_HERMES is only set on Android so we have to check __has_include
+// on iOS.
+#if __APPLE__ &&    \
+    (__has_include( \
+        <reacthermes/HermesExecutorFactory.h>) || __has_include(<hermes/hermes.h>))
+#define JS_RUNTIME_HERMES 1
+#endif
+
+// Only include this file in Hermes-enabled builds as some platforms (like tvOS)
+// don't support hermes and it causes the compilation to fail.
+#if JS_RUNTIME_HERMES
+
+#include <cxxreact/MessageQueueThread.h>
+#include <jsi/decorator.h>
+#include <jsi/jsi.h>
+
+#include <atomic>
+#include <memory>
+#include <string>
+#include <thread>
+
+#if __has_include(<reacthermes/HermesExecutorFactory.h>)
+#include <reacthermes/HermesExecutorFactory.h>
+#else // __has_include(<hermes/hermes.h>) || ANDROID
+#include <hermes/hermes.h>
+#endif
+
+#if HERMES_ENABLE_DEBUGGER
+#if REACT_NATIVE_MINOR_VERSION >= 73
+#include <hermes/inspector-modern/chrome/Registration.h>
+#else
+#include <hermes/inspector/RuntimeAdapter.h>
+#include <hermes/inspector/chrome/Registration.h>
+#endif
+#endif // HERMES_ENABLE_DEBUGGER
+
+namespace reanimated {
+
+using namespace facebook;
+using namespace react;
+#if HERMES_ENABLE_DEBUGGER
+#if REACT_NATIVE_MINOR_VERSION >= 73
+using namespace facebook::hermes::inspector_modern;
+#else
+using namespace facebook::hermes::inspector;
+#endif
+#endif // HERMES_ENABLE_DEBUGGER
+
+// ReentrancyCheck is copied from React Native
+// from ReactCommon/hermes/executor/HermesExecutorFactory.cpp
+// https://github.com/facebook/react-native/blob/main/packages/react-native/ReactCommon/hermes/executor/HermesExecutorFactory.cpp
+struct ReanimatedReentrancyCheck {
+  // This is effectively a very subtle and complex assert, so only
+  // include it in builds which would include asserts.
+#ifndef NDEBUG
+  ReanimatedReentrancyCheck() : tid(std::thread::id()), depth(0) {}
+
+  void before() {
+    std::thread::id this_id = std::this_thread::get_id();
+    std::thread::id expected = std::thread::id();
+
+    // A note on memory ordering: the main purpose of these checks is
+    // to observe a before/before race, without an intervening after.
+    // This will be detected by the compare_exchange_strong atomicity
+    // properties, regardless of memory order.
+    //
+    // For everything else, it is easiest to think of 'depth' as a
+    // proxy for any access made inside the VM.  If access to depth
+    // are reordered incorrectly, the same could be true of any other
+    // operation made by the VM.  In fact, using acquire/release
+    // memory ordering could create barriers which mask a programmer
+    // error.  So, we use relaxed memory order, to avoid masking
+    // actual ordering errors.  Although, in practice, ordering errors
+    // of this sort would be surprising, because the decorator would
+    // need to call after() without before().
+
+    if (tid.compare_exchange_strong(
+            expected, this_id, std::memory_order_relaxed)) {
+      // Returns true if tid and expected were the same.  If they
+      // were, then the stored tid referred to no thread, and we
+      // atomically saved this thread's tid.  Now increment depth.
+      assert(depth == 0 && "[Reanimated] No thread id, but depth != 0");
+      ++depth;
+    } else if (expected == this_id) {
+      // If the stored tid referred to a thread, expected was set to
+      // that value.  If that value is this thread's tid, that's ok,
+      // just increment depth again.
+      assert(depth != 0 && "[Reanimated] Thread id was set, but depth == 0");
+      ++depth;
+    } else {
+      // The stored tid was some other thread.  This indicates a bad
+      // programmer error, where VM methods were called on two
+      // different threads unsafely.  Fail fast (and hard) so the
+      // crash can be analyzed.
+      __builtin_trap();
+    }
+  }
+
+  void after() {
+    assert(
+        tid.load(std::memory_order_relaxed) == std::this_thread::get_id() &&
+        "[Reanimated] No thread id in after()");
+    if (--depth == 0) {
+      // If we decremented depth to zero, store no-thread into tid.
+      std::thread::id expected = std::this_thread::get_id();
+      bool didWrite = tid.compare_exchange_strong(
+          expected, std::thread::id(), std::memory_order_relaxed);
+      assert(didWrite && "[Reanimated] Decremented to zero, but no tid write");
+    }
+  }
+
+  std::atomic<std::thread::id> tid;
+  // This is not atomic, as it is only written or read from the owning
+  // thread.
+  unsigned int depth;
+#endif // NDEBUG
+};
+
+// This is in fact a subclass of jsi::Runtime! WithRuntimeDecorator is a
+// template class that is a subclass of DecoratedRuntime which is also a
+// template class that then inherits its template, which in this case is
+// jsi::Runtime. So the inheritance is: ReanimatedHermesRuntime ->
+// WithRuntimeDecorator -> DecoratedRuntime -> jsi::Runtime You can find out
+// more about this in ReactCommon/jsi/jsi/Decorator.h or by following this link:
+// https://github.com/facebook/react-native/blob/main/packages/react-native/ReactCommon/jsi/jsi/decorator.h
+class ReanimatedHermesRuntime
+    : public jsi::WithRuntimeDecorator<ReanimatedReentrancyCheck> {
+ public:
+  ReanimatedHermesRuntime(
+      std::unique_ptr<facebook::hermes::HermesRuntime> runtime,
+      const std::shared_ptr<MessageQueueThread> &jsQueue,
+      const std::string &name);
+  ~ReanimatedHermesRuntime();
+
+ private:
+  std::unique_ptr<facebook::hermes::HermesRuntime> runtime_;
+  ReanimatedReentrancyCheck reentrancyCheck_;
+#if HERMES_ENABLE_DEBUGGER
+#if REACT_NATIVE_MINOR_VERSION >= 71
+  chrome::DebugSessionToken debugToken_;
+#endif // REACT_NATIVE_MINOR_VERSION >= 71
+#endif // HERMES_ENABLE_DEBUGGER
+};
+
+} // namespace reanimated
+
+#endif // JS_RUNTIME_HERMES
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedHiddenHeaders.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedHiddenHeaders.h
new file mode 100644
index 0000000..c1a0545
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedHiddenHeaders.h
@@ -0,0 +1,11 @@
+#pragma once
+
+#ifdef ANDROID
+#include "Logger.h"
+#include "LoggerInterface.h"
+#include "SpeedChecker.h"
+#else
+#include "Common/cpp/hidden_headers/Logger.h"
+#include "Common/cpp/hidden_headers/LoggerInterface.h"
+#include "Common/cpp/hidden_headers/SpeedChecker.h"
+#endif
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedJSIUtils.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedJSIUtils.h
new file mode 100644
index 0000000..f97925e
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedJSIUtils.h
@@ -0,0 +1,176 @@
+#pragma once
+
+#include <jsi/jsi.h>
+#include <sstream>
+#include <string>
+#include <tuple>
+#include <utility>
+
+using namespace facebook;
+
+namespace reanimated {
+namespace jsi_utils {
+
+// `get` functions take a pointer to `jsi::Value` and
+// call an appropriate method to cast to the native type
+template <typename T>
+inline T get(jsi::Runtime &rt, const jsi::Value *value);
+
+template <>
+inline double get<double>(jsi::Runtime &, const jsi::Value *value) {
+  return value->asNumber();
+}
+
+template <>
+inline int get<int>(jsi::Runtime &, const jsi::Value *value) {
+  return value->asNumber();
+}
+
+template <>
+inline bool get<bool>(jsi::Runtime &, const jsi::Value *value) {
+  if (!value->isBool()) {
+    throw jsi::JSINativeException("[Reanimated] Expected a boolean.");
+  }
+  return value->getBool();
+}
+
+template <>
+inline jsi::Object get<jsi::Object>(jsi::Runtime &rt, const jsi::Value *value) {
+  return value->asObject(rt);
+}
+
+template <>
+inline jsi::Value const &get<jsi::Value const &>(
+    jsi::Runtime &,
+    const jsi::Value *value) {
+  return *value;
+}
+
+// `convertArgs` functions take a variadic template parameter of target (C++)
+// argument types `Targs` and a `jsi::Value` array `args`, and converts `args`
+// to a tuple of typed C++ arguments to be passed to the native implementation.
+// This is accomplished by dispatching (at compile time) to the correct
+// implementation based on the first type of `Targs`, using SFINAE to select the
+// correct specialization, and concatenating with the result of recursion on the
+// rest of `Targs`
+
+// BEGIN implementations for `convertArgs` specializations.
+// specialization for empty `Targs` - returns an empty tuple
+template <typename... Args>
+inline std::enable_if_t<(sizeof...(Args) == 0), std::tuple<>> convertArgs(
+    jsi::Runtime &,
+    const jsi::Value *) {
+  return std::make_tuple();
+}
+
+// calls `get<First>` on the first argument to retrieve the native type,
+// then calls recursively on the rest of `args`
+// and returns the concatenation of results
+template <typename T, typename... Rest>
+inline std::tuple<T, Rest...> convertArgs(
+    jsi::Runtime &rt,
+    const jsi::Value *args) {
+  auto arg = std::tuple<T>(get<T>(rt, args));
+  auto rest = convertArgs<Rest...>(rt, std::next(args));
+  return std::tuple_cat(std::move(arg), std::move(rest));
+}
+// END implementations for `convertArgs` specializations.
+
+// returns a tuple with the result of casting `args` to appropriate
+// native C++ types needed to call `function`
+template <typename Ret, typename... Args>
+std::tuple<Args...> getArgsForFunction(
+    std::function<Ret(Args...)>,
+    jsi::Runtime &rt,
+    const jsi::Value *args,
+    const size_t count) {
+  assert(sizeof...(Args) == count);
+  return convertArgs<Args...>(rt, args);
+}
+
+// returns a tuple with the result of casting `args` to appropriate
+// native C++ types needed to call `function`,
+// passing `rt` as the first argument
+template <typename Ret, typename... Args>
+std::tuple<jsi::Runtime &, Args...> getArgsForFunction(
+    std::function<Ret(jsi::Runtime &, Args...)>,
+    jsi::Runtime &rt,
+    const jsi::Value *args,
+    const size_t count) {
+  assert(sizeof...(Args) == count);
+  return std::tuple_cat(std::tie(rt), convertArgs<Args...>(rt, args));
+}
+
+// calls `function` with `args`
+template <typename Ret, typename... Args>
+inline jsi::Value apply(
+    std::function<Ret(Args...)> function,
+    std::tuple<Args...> args) {
+  return std::apply(function, std::move(args));
+}
+
+// calls void-returning `function` with `args`,
+// and returns `undefined`
+template <typename... Args>
+inline jsi::Value apply(
+    std::function<void(Args...)> function,
+    std::tuple<Args...> args) {
+  std::apply(function, std::move(args));
+  return jsi::Value::undefined();
+}
+
+// returns a function with JSI calling convention
+// from a native function `function`
+template <typename Fun>
+jsi::HostFunctionType createHostFunction(Fun function) {
+  return [function](
+             jsi::Runtime &rt,
+             const jsi::Value &,
+             const jsi::Value *args,
+             const size_t count) {
+    auto argz = getArgsForFunction(function, rt, args, count);
+    return apply(function, std::move(argz));
+  };
+}
+
+// used to determine if `function<Ret(Args...)>`
+// takes `Runtime &` as its first argument
+template <typename... Args>
+struct takes_runtime {
+  static constexpr size_t value = 0;
+};
+
+// specialization for `function<Ret(Runtime &, Rest...)`
+template <typename... Rest>
+struct takes_runtime<jsi::Runtime &, Rest...> {
+  static constexpr size_t value = 1;
+};
+
+// creates a JSI compatible function from `function`
+// and installs it as a global function named `name`
+// in the `rt` JS runtime
+template <typename Ret, typename... Args>
+void installJsiFunction(
+    jsi::Runtime &rt,
+    std::string_view name,
+    std::function<Ret(Args...)> function) {
+  auto clb = createHostFunction(function);
+  auto argsCount = sizeof...(Args) - takes_runtime<Args...>::value;
+  jsi::Value jsiFunction = jsi::Function::createFromHostFunction(
+      rt, jsi::PropNameID::forAscii(rt, name.data()), argsCount, clb);
+  rt.global().setProperty(rt, name.data(), jsiFunction);
+}
+
+// this should take care of passing types convertible to `function`
+template <typename Fun>
+void installJsiFunction(jsi::Runtime &rt, std::string_view name, Fun function) {
+  installJsiFunction(rt, name, std::function(std::forward<Fun>(function)));
+}
+
+jsi::Array convertStringToArray(
+    jsi::Runtime &rt,
+    const std::string &value,
+    const unsigned int expectedSize);
+
+} // namespace jsi_utils
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedMountHook.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedMountHook.h
new file mode 100644
index 0000000..f5b8976
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedMountHook.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#if defined(RCT_NEW_ARCH_ENABLED) && REACT_NATIVE_MINOR_VERSION >= 73
+
+#include "PropsRegistry.h"
+
+#include <react/renderer/uimanager/UIManagerMountHook.h>
+
+#include <memory>
+
+namespace reanimated {
+
+using namespace facebook::react;
+
+class ReanimatedMountHook : public UIManagerMountHook {
+ public:
+  ReanimatedMountHook(
+      const std::shared_ptr<PropsRegistry> &propsRegistry,
+      const std::shared_ptr<UIManager> &uiManager);
+  ~ReanimatedMountHook() noexcept override;
+
+  void shadowTreeDidMount(
+      RootShadowNode::Shared const &rootShadowNode,
+      double mountTime) noexcept override;
+
+ private:
+  const std::shared_ptr<PropsRegistry> propsRegistry_;
+  const std::shared_ptr<UIManager> uiManager_;
+};
+
+} // namespace reanimated
+
+#endif // defined(RCT_NEW_ARCH_ENABLED) && REACT_NATIVE_MINOR_VERSION >= 73
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedRuntime.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedRuntime.h
new file mode 100644
index 0000000..69daa19
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedRuntime.h
@@ -0,0 +1,30 @@
+#pragma once
+
+// JS_RUNTIME_HERMES is only set on Android so we have to check __has_include
+// on iOS.
+#if __APPLE__ &&    \
+    (__has_include( \
+        <reacthermes/HermesExecutorFactory.h>) || __has_include(<hermes/hermes.h>))
+#define JS_RUNTIME_HERMES 1
+#endif
+
+#include <cxxreact/MessageQueueThread.h>
+#include <jsi/jsi.h>
+
+#include <memory>
+#include <string>
+
+namespace reanimated {
+
+using namespace facebook;
+using namespace react;
+
+class ReanimatedRuntime {
+ public:
+  static std::shared_ptr<jsi::Runtime> make(
+      jsi::Runtime &rnRuntime,
+      const std::shared_ptr<MessageQueueThread> &jsQueue,
+      const std::string &name);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedVersion.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedVersion.h
new file mode 100644
index 0000000..ac5971e
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ReanimatedVersion.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include <jsi/jsi.h>
+#include <memory>
+#include <string>
+#include "JSLogger.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+std::string getReanimatedCppVersion();
+void injectReanimatedCppVersion(jsi::Runtime &);
+bool matchVersion(const std::string &, const std::string &);
+void checkJSVersion(jsi::Runtime &, const std::shared_ptr<JSLogger> &);
+
+}; // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ShadowTreeCloner.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ShadowTreeCloner.h
new file mode 100644
index 0000000..f759d35
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ShadowTreeCloner.h
@@ -0,0 +1,22 @@
+#pragma once
+#ifdef RCT_NEW_ARCH_ENABLED
+
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/uimanager/UIManager.h>
+
+#include <memory>
+#include <set>
+
+using namespace facebook;
+using namespace react;
+
+namespace reanimated {
+
+ShadowNode::Unshared cloneShadowTreeWithNewProps(
+    const ShadowNode::Shared &oldRootNode,
+    const ShadowNodeFamily &family,
+    RawProps &&rawProps);
+
+} // namespace reanimated
+
+#endif // RCT_NEW_ARCH_ENABLED
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/Shareables.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/Shareables.h
new file mode 100644
index 0000000..afe09e6
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/Shareables.h
@@ -0,0 +1,345 @@
+#pragma once
+
+#include <jsi/jsi.h>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "WorkletRuntimeRegistry.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+jsi::Function getValueUnpacker(jsi::Runtime &rt);
+
+#ifndef NDEBUG
+jsi::Function getCallGuard(jsi::Runtime &rt);
+#endif // NDEBUG
+
+// If possible, please use `WorkletRuntime::runGuarded` instead.
+template <typename... Args>
+inline jsi::Value runOnRuntimeGuarded(
+    jsi::Runtime &rt,
+    const jsi::Value &function,
+    Args &&...args) {
+  // We only use callGuard in debug mode, otherwise we call the provided
+  // function directly. CallGuard provides a way of capturing exceptions in
+  // JavaScript and propagating them to the main React Native thread such that
+  // they can be presented using RN's LogBox.
+#ifndef NDEBUG
+  return getCallGuard(rt).call(rt, function, args...);
+#else
+  return function.asObject(rt).asFunction(rt).call(rt, args...);
+#endif
+}
+
+inline void cleanupIfRuntimeExists(
+    jsi::Runtime *rt,
+    std::unique_ptr<jsi::Value> &value) {
+  if (rt != nullptr && !WorkletRuntimeRegistry::isRuntimeAlive(rt)) {
+    // The below use of unique_ptr.release prevents the smart pointer from
+    // calling the destructor of the kept object. This effectively results in
+    // leaking some memory. We do this on purpose, as sometimes we would keep
+    // references to JSI objects past the lifetime of its runtime (e.g.,
+    // shared values references from the RN VM holds reference to JSI objects
+    // on the UI runtime). When the UI runtime is terminated, the orphaned JSI
+    // objects would crash the app when their destructors are called, because
+    // they call into a memory that's managed by the terminated runtime. We
+    // accept the tradeoff of leaking memory here, as it has a limited impact.
+    // This scenario can only occur when the React instance is torn down which
+    // happens in development mode during app reloads, or in production when
+    // the app is being shut down gracefully by the system. An alternative
+    // solution would require us to keep track of all JSI values that are in
+    // use which would require additional data structure and compute spent on
+    // bookkeeping that only for the sake of destroying the values in time
+    // before the runtime is terminated. Note that the underlying memory that
+    // jsi::Value refers to is managed by the VM and gets freed along with the
+    // runtime.
+    value.release();
+  }
+}
+
+class Shareable {
+ protected:
+  virtual jsi::Value toJSValue(jsi::Runtime &rt) = 0;
+
+ public:
+  virtual ~Shareable();
+
+  enum ValueType {
+    UndefinedType,
+    NullType,
+    BooleanType,
+    NumberType,
+    // SymbolType, TODO
+    BigIntType,
+    StringType,
+    ObjectType,
+    ArrayType,
+    WorkletType,
+    RemoteFunctionType,
+    HandleType,
+    HostObjectType,
+    HostFunctionType,
+    ArrayBufferType,
+  };
+
+  explicit Shareable(ValueType valueType) : valueType_(valueType) {}
+
+  virtual jsi::Value getJSValue(jsi::Runtime &rt) {
+    return toJSValue(rt);
+  }
+
+  inline ValueType valueType() const {
+    return valueType_;
+  }
+
+  static std::shared_ptr<Shareable> undefined();
+
+ protected:
+  ValueType valueType_;
+};
+
+template <typename BaseClass>
+class RetainingShareable : virtual public BaseClass {
+ private:
+  jsi::Runtime *primaryRuntime_;
+  jsi::Runtime *secondaryRuntime_;
+  std::unique_ptr<jsi::Value> secondaryValue_;
+
+ public:
+  template <typename... Args>
+  explicit RetainingShareable(jsi::Runtime &rt, Args &&...args)
+      : BaseClass(rt, std::forward<Args>(args)...), primaryRuntime_(&rt) {}
+
+  jsi::Value getJSValue(jsi::Runtime &rt);
+
+  ~RetainingShareable() {
+    cleanupIfRuntimeExists(secondaryRuntime_, secondaryValue_);
+  }
+};
+
+class ShareableJSRef : public jsi::HostObject {
+ private:
+  const std::shared_ptr<Shareable> value_;
+
+ public:
+  explicit ShareableJSRef(const std::shared_ptr<Shareable> &value)
+      : value_(value) {}
+
+  virtual ~ShareableJSRef();
+
+  std::shared_ptr<Shareable> value() const {
+    return value_;
+  }
+
+  static jsi::Object newHostObject(
+      jsi::Runtime &rt,
+      const std::shared_ptr<Shareable> &value) {
+    return jsi::Object::createFromHostObject(
+        rt, std::make_shared<ShareableJSRef>(value));
+  }
+};
+
+jsi::Value makeShareableClone(
+    jsi::Runtime &rt,
+    const jsi::Value &value,
+    const jsi::Value &shouldRetainRemote);
+
+std::shared_ptr<Shareable> extractShareableOrThrow(
+    jsi::Runtime &rt,
+    const jsi::Value &maybeShareableValue,
+    const std::string &errorMessage =
+        "[Reanimated] Expecting the object to be of type ShareableJSRef.");
+
+template <typename T>
+std::shared_ptr<T> extractShareableOrThrow(
+    jsi::Runtime &rt,
+    const jsi::Value &shareableRef,
+    const std::string &errorMessage =
+        "[Reanimated] Provided shareable object is of an incompatible type.") {
+  auto res = std::dynamic_pointer_cast<T>(
+      extractShareableOrThrow(rt, shareableRef, errorMessage));
+  if (!res) {
+    throw std::runtime_error(errorMessage);
+  }
+  return res;
+}
+
+class ShareableArray : public Shareable {
+ public:
+  ShareableArray(jsi::Runtime &rt, const jsi::Array &array);
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  std::vector<std::shared_ptr<Shareable>> data_;
+};
+
+class ShareableObject : public Shareable {
+ public:
+  ShareableObject(jsi::Runtime &rt, const jsi::Object &object);
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  std::vector<std::pair<std::string, std::shared_ptr<Shareable>>> data_;
+};
+
+class ShareableHostObject : public Shareable {
+ public:
+  ShareableHostObject(
+      jsi::Runtime &,
+      const std::shared_ptr<jsi::HostObject> &hostObject)
+      : Shareable(HostObjectType), hostObject_(hostObject) {}
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  const std::shared_ptr<jsi::HostObject> hostObject_;
+};
+
+class ShareableHostFunction : public Shareable {
+ public:
+  ShareableHostFunction(jsi::Runtime &rt, jsi::Function function)
+      : Shareable(HostFunctionType),
+        hostFunction_(
+            (assert(function.isHostFunction(rt)),
+             function.getHostFunction(rt))),
+        name_(function.getProperty(rt, "name").asString(rt).utf8(rt)),
+        paramCount_(function.getProperty(rt, "length").asNumber()) {}
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  const jsi::HostFunctionType hostFunction_;
+  const std::string name_;
+  const unsigned int paramCount_;
+};
+
+class ShareableArrayBuffer : public Shareable {
+ public:
+  ShareableArrayBuffer(
+      jsi::Runtime &rt,
+#if REACT_NATIVE_MINOR_VERSION >= 72
+      const jsi::ArrayBuffer &arrayBuffer
+#else
+      jsi::ArrayBuffer arrayBuffer
+#endif
+      )
+      : Shareable(ArrayBufferType),
+        data_(
+            arrayBuffer.data(rt),
+            arrayBuffer.data(rt) + arrayBuffer.size(rt)) {
+  }
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  const std::vector<uint8_t> data_;
+};
+
+class ShareableWorklet : public ShareableObject {
+ public:
+  ShareableWorklet(jsi::Runtime &rt, const jsi::Object &worklet)
+      : ShareableObject(rt, worklet) {
+    valueType_ = WorkletType;
+  }
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+};
+
+class ShareableRemoteFunction
+    : public Shareable,
+      public std::enable_shared_from_this<ShareableRemoteFunction> {
+ private:
+  jsi::Runtime *runtime_;
+  std::unique_ptr<jsi::Value> function_;
+
+ public:
+  ShareableRemoteFunction(jsi::Runtime &rt, jsi::Function &&function)
+      : Shareable(RemoteFunctionType),
+        runtime_(&rt),
+        function_(std::make_unique<jsi::Value>(rt, std::move(function))) {}
+
+  ~ShareableRemoteFunction() {
+    cleanupIfRuntimeExists(runtime_, function_);
+  }
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+};
+
+class ShareableHandle : public Shareable {
+ private:
+  // We don't release the initializer since the handle can get
+  // initialized in parallel on multiple threads. However this is not a problem,
+  // since the final value is taken from a cache on the runtime which guarantees
+  // sequential access.
+  std::unique_ptr<ShareableObject> initializer_;
+  std::unique_ptr<jsi::Value> remoteValue_;
+  mutable std::mutex initializationMutex_;
+  jsi::Runtime *remoteRuntime_;
+
+ public:
+  ShareableHandle(jsi::Runtime &rt, const jsi::Object &initializerObject)
+      : Shareable(HandleType),
+        initializer_(std::make_unique<ShareableObject>(rt, initializerObject)) {
+  }
+
+  ~ShareableHandle() {
+    cleanupIfRuntimeExists(remoteRuntime_, remoteValue_);
+  }
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+};
+
+class ShareableString : public Shareable {
+ public:
+  explicit ShareableString(const std::string &string)
+      : Shareable(StringType), data_(string) {}
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  const std::string data_;
+};
+
+#if REACT_NATIVE_MINOR_VERSION >= 71
+class ShareableBigInt : public Shareable {
+ public:
+  explicit ShareableBigInt(jsi::Runtime &rt, const jsi::BigInt &bigint)
+      : Shareable(BigIntType), string_(bigint.toString(rt).utf8(rt)) {}
+
+  jsi::Value toJSValue(jsi::Runtime &rt) override;
+
+ protected:
+  const std::string string_;
+};
+#endif
+
+class ShareableScalar : public Shareable {
+ public:
+  explicit ShareableScalar(double number) : Shareable(NumberType) {
+    data_.number = number;
+  }
+  explicit ShareableScalar(bool boolean) : Shareable(BooleanType) {
+    data_.boolean = boolean;
+  }
+  ShareableScalar() : Shareable(UndefinedType) {}
+  explicit ShareableScalar(std::nullptr_t) : Shareable(NullType) {}
+
+  jsi::Value toJSValue(jsi::Runtime &);
+
+ protected:
+  union Data {
+    bool boolean;
+    double number;
+  };
+
+ private:
+  Data data_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/SingleInstanceChecker.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/SingleInstanceChecker.h
new file mode 100644
index 0000000..2a183e8
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/SingleInstanceChecker.h
@@ -0,0 +1,71 @@
+#pragma once
+
+#ifndef NDEBUG
+
+#include <cxxabi.h>
+
+#include <atomic>
+#include <iostream>
+#include <string>
+
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
+namespace reanimated {
+
+// This is a class that counts how many instances of a different class there
+// are. It is meant only to be used with classes that should only have one
+// instance.
+
+template <class T>
+class SingleInstanceChecker {
+ public:
+  SingleInstanceChecker();
+  ~SingleInstanceChecker();
+
+ private:
+  void assertWithMessage(bool condition, std::string message) {
+    if (!condition) {
+#ifdef ANDROID
+      __android_log_print(
+          ANDROID_LOG_WARN, "Reanimated", "%s", message.c_str());
+#else
+      std::cerr << "[Reanimated] " << message << std::endl;
+#endif
+
+#ifdef IS_REANIMATED_EXAMPLE_APP
+      assert(false);
+#endif
+    }
+  }
+
+  // A static field will exist separately for every class template.
+  // This has to be inline for automatic initialization.
+  inline static std::atomic<int> instanceCount_;
+};
+
+template <class T>
+SingleInstanceChecker<T>::SingleInstanceChecker() {
+  int status = 0;
+  std::string className =
+      __cxxabiv1::__cxa_demangle(typeid(T).name(), nullptr, nullptr, &status);
+
+  // Only one instance should exist, but it is possible for two instances
+  // to co-exist during a reload.
+  assertWithMessage(
+      instanceCount_ <= 1,
+      "[Reanimated] More than one instance of " + className +
+          " present. This may indicate a memory leak due to a retain cycle.");
+
+  instanceCount_++;
+}
+
+template <class T>
+SingleInstanceChecker<T>::~SingleInstanceChecker() {
+  instanceCount_--;
+}
+
+} // namespace reanimated
+
+#endif // NDEBUG
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ThreadSafeQueue.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ThreadSafeQueue.h
new file mode 100644
index 0000000..7d7e804
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/ThreadSafeQueue.h
@@ -0,0 +1,49 @@
+#pragma once
+
+#include <condition_variable>
+#include <mutex>
+#include <queue>
+#include <utility>
+
+namespace reanimated {
+
+//
+// Copyright (c) 2013 Juan Palacios juan.palacios.puyana@gmail.com
+// Subject to the BSD 2-Clause License
+// - see < https://opensource.org/license/bsd-2-clause/ >
+//
+template <typename T>
+class ThreadSafeQueue {
+ public:
+  T pop() {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    while (queue_.empty()) {
+      cond_.wait(mlock);
+    }
+    const auto item = queue_.front();
+    queue_.pop();
+    return item;
+  }
+
+  void push(T &&item) {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    queue_.push(std::move(item));
+    mlock.unlock();
+    cond_.notify_one();
+  }
+
+  bool empty() const {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    const auto res = queue_.empty();
+    mlock.unlock();
+    cond_.notify_one();
+    return res;
+  }
+
+ private:
+  std::queue<T> queue_;
+  mutable std::mutex mutex_;
+  mutable std::condition_variable cond_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/TurboModule.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/TurboModule.h
new file mode 100644
index 0000000..6fd21c7
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/TurboModule.h
@@ -0,0 +1,72 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <ReactCommon/CallInvoker.h>
+#include <jsi/jsi.h>
+#include <memory>
+#include <string>
+#include <unordered_map>
+
+namespace facebook {
+namespace react {
+
+/**
+ * For now, support the same set of return types as existing impl.
+ * This can be improved to support richer typed objects.
+ */
+enum TurboModuleMethodValueKind {
+  VoidKind,
+  BooleanKind,
+  NumberKind,
+  StringKind,
+  ObjectKind,
+  ArrayKind,
+  FunctionKind,
+  PromiseKind,
+};
+
+/**
+ * Base HostObject class for every module to be exposed to JS
+ */
+class JSI_EXPORT TurboModule : public facebook::jsi::HostObject {
+ public:
+  TurboModule(
+      const std::string &name,
+      const std::shared_ptr<CallInvoker> &jsInvoker);
+  virtual ~TurboModule();
+
+  facebook::jsi::Value get(
+      facebook::jsi::Runtime &runtime,
+      const facebook::jsi::PropNameID &propName) override;
+
+  const std::string name_;
+  const std::shared_ptr<CallInvoker> jsInvoker_;
+
+ protected:
+  struct MethodMetadata {
+    size_t argCount;
+    facebook::jsi::Value (*invoker)(
+        facebook::jsi::Runtime &rt,
+        TurboModule &turboModule,
+        const facebook::jsi::Value *args,
+        size_t count);
+  };
+
+  std::unordered_map<std::string, MethodMetadata> methodMap_;
+};
+
+/**
+ * An app/platform-specific provider function to get an instance of a module
+ * given a name.
+ */
+using TurboModuleProviderFunctionType =
+    std::function<std::shared_ptr<TurboModule>(const std::string &name)>;
+
+} // namespace react
+} // namespace facebook
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/UIRuntimeDecorator.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/UIRuntimeDecorator.h
new file mode 100644
index 0000000..447f855
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/UIRuntimeDecorator.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include <jsi/jsi.h>
+
+#include "PlatformDepMethodsHolder.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+using RequestAnimationFrameFunction =
+    std::function<void(jsi::Runtime &, const jsi::Value &)>;
+
+class UIRuntimeDecorator {
+ public:
+  static void decorate(
+      jsi::Runtime &uiRuntime,
+#ifdef RCT_NEW_ARCH_ENABLED
+      const RemoveFromPropsRegistryFunction removeFromPropsRegistry,
+#else
+      const ScrollToFunction scrollTo,
+#endif
+      const UpdatePropsFunction updateProps,
+      const MeasureFunction measure,
+      const DispatchCommandFunction dispatchCommand,
+      const RequestAnimationFrameFunction requestAnimationFrame,
+      const GetAnimationTimestampFunction getAnimationTimestamp,
+      const SetGestureStateFunction setGestureState,
+      const ProgressLayoutAnimationFunction progressLayoutAnimation,
+      const EndLayoutAnimationFunction endLayoutAnimation,
+      const MaybeFlushUIUpdatesQueueFunction maybeFlushUIUpdatesQueue);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/UIScheduler.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/UIScheduler.h
new file mode 100644
index 0000000..787b369
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/UIScheduler.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include <ReactCommon/CallInvoker.h>
+
+#include <atomic>
+#include <memory>
+
+#include "ThreadSafeQueue.h"
+
+namespace reanimated {
+
+class UIScheduler {
+ public:
+  virtual void scheduleOnUI(std::function<void()> job);
+  virtual void triggerUI();
+  virtual ~UIScheduler() = default;
+
+ protected:
+  std::atomic<bool> scheduledOnUI_{false};
+  ThreadSafeQueue<std::function<void()>> uiJobs_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletEventHandler.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletEventHandler.h
new file mode 100644
index 0000000..1d61cc2
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletEventHandler.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include <jsi/jsi.h>
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "Shareables.h"
+#include "WorkletRuntime.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+class WorkletEventHandler {
+  const uint64_t handlerId_;
+  const uint64_t emitterReactTag_;
+  const std::string eventName_;
+  const std::shared_ptr<ShareableWorklet> handlerFunction_;
+
+ public:
+  WorkletEventHandler(
+      const uint64_t handlerId,
+      const std::string &eventName,
+      const uint64_t emitterReactTag,
+      const std::shared_ptr<ShareableWorklet> &handlerFunction)
+      : handlerId_(handlerId),
+        emitterReactTag_(emitterReactTag),
+        eventName_(eventName),
+        handlerFunction_(handlerFunction) {}
+  void process(
+      const std::shared_ptr<WorkletRuntime> &workletRuntime,
+      double eventTimestamp,
+      const jsi::Value &eventValue) const;
+  uint64_t getHandlerId() const;
+  const std::string &getEventName() const;
+  uint64_t getEmitterReactTag() const;
+  bool shouldIgnoreEmitterReactTag() const;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntime.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntime.h
new file mode 100644
index 0000000..2131b95
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntime.h
@@ -0,0 +1,85 @@
+#pragma once
+
+#include <cxxreact/MessageQueueThread.h>
+#include <jsi/jsi.h>
+
+#include "AsyncQueue.h"
+#include "JSScheduler.h"
+#include "Shareables.h"
+
+#include <memory>
+#include <string>
+#include <thread>
+#include <utility>
+#include <vector>
+
+using namespace facebook;
+using namespace react;
+
+namespace reanimated {
+
+class WorkletRuntime : public jsi::HostObject,
+                       public std::enable_shared_from_this<WorkletRuntime> {
+ public:
+  explicit WorkletRuntime(
+      jsi::Runtime &rnRuntime,
+      const std::shared_ptr<MessageQueueThread> &jsQueue,
+      const std::shared_ptr<JSScheduler> &jsScheduler,
+      const std::string &name,
+      const bool supportsLocking,
+      const std::string &valueUnpackerCode);
+
+  jsi::Runtime &getJSIRuntime() const {
+    return *runtime_;
+  }
+
+  template <typename... Args>
+  inline jsi::Value runGuarded(
+      const std::shared_ptr<ShareableWorklet> &shareableWorklet,
+      Args &&...args) const {
+    jsi::Runtime &rt = *runtime_;
+    return runOnRuntimeGuarded(
+        rt, shareableWorklet->getJSValue(rt), std::forward<Args>(args)...);
+  }
+
+  void runAsyncGuarded(
+      const std::shared_ptr<ShareableWorklet> &shareableWorklet) {
+    if (queue_ == nullptr) {
+      queue_ = std::make_shared<AsyncQueue>(name_);
+    }
+    queue_->push(
+        [=, self = shared_from_this()] { self->runGuarded(shareableWorklet); });
+  }
+
+  jsi::Value executeSync(jsi::Runtime &rt, const jsi::Value &worklet) const;
+
+  std::string toString() const {
+    return "[WorkletRuntime \"" + name_ + "\"]";
+  }
+
+  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override;
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime &rt) override;
+
+ private:
+  const std::shared_ptr<std::recursive_mutex> runtimeMutex_;
+  const std::shared_ptr<jsi::Runtime> runtime_;
+#ifndef NDEBUG
+  const bool supportsLocking_;
+#endif
+  const std::string name_;
+  std::shared_ptr<AsyncQueue> queue_;
+};
+
+// This function needs to be non-inline to avoid problems with dynamic_cast on
+// Android
+std::shared_ptr<WorkletRuntime> extractWorkletRuntime(
+    jsi::Runtime &rt,
+    const jsi::Value &value);
+
+void scheduleOnRuntime(
+    jsi::Runtime &rt,
+    const jsi::Value &workletRuntimeValue,
+    const jsi::Value &shareableWorkletValue);
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeCollector.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeCollector.h
new file mode 100644
index 0000000..b2ef502
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeCollector.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "WorkletRuntimeRegistry.h"
+
+#include <jsi/jsi.h>
+
+#include <memory>
+
+namespace reanimated {
+
+class WorkletRuntimeCollector : public jsi::HostObject {
+  // When worklet runtime is created, we inject an instance of this class as a
+  // `jsi::HostObject` into the global object. When worklet runtime is
+  // terminated, the object is garbage-collected, which runs the C++ destructor.
+  // In the destructor, we unregister the worklet runtime from the registry.
+
+ public:
+  explicit WorkletRuntimeCollector(jsi::Runtime &runtime) : runtime_(runtime) {
+    WorkletRuntimeRegistry::registerRuntime(runtime_);
+  }
+
+  ~WorkletRuntimeCollector() {
+    WorkletRuntimeRegistry::unregisterRuntime(runtime_);
+  }
+
+  static void install(jsi::Runtime &rt) {
+    auto collector = std::make_shared<WorkletRuntimeCollector>(rt);
+    auto object = jsi::Object::createFromHostObject(rt, collector);
+    rt.global().setProperty(rt, "__workletRuntimeCollector", object);
+  }
+
+ private:
+  jsi::Runtime &runtime_;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeDecorator.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeDecorator.h
new file mode 100644
index 0000000..0c35b4b
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeDecorator.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "JSScheduler.h"
+
+#include <jsi/jsi.h>
+
+#include <memory>
+#include <string>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class WorkletRuntimeDecorator {
+ public:
+  static void decorate(
+      jsi::Runtime &rt,
+      const std::string &name,
+      const std::shared_ptr<JSScheduler> &jsScheduler);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeRegistry.h b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeRegistry.h
new file mode 100644
index 0000000..1fdea1c
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build/prefab-headers/reanimated/WorkletRuntimeRegistry.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include <jsi/jsi.h>
+
+#include <mutex>
+#include <set>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class WorkletRuntimeRegistry {
+ private:
+  static std::set<jsi::Runtime *> registry_;
+  static std::mutex mutex_; // Protects `registry_`.
+
+  WorkletRuntimeRegistry() {} // private ctor
+
+  static void registerRuntime(jsi::Runtime &runtime) {
+    std::lock_guard<std::mutex> lock(mutex_);
+    registry_.insert(&runtime);
+  }
+
+  static void unregisterRuntime(jsi::Runtime &runtime) {
+    std::lock_guard<std::mutex> lock(mutex_);
+    registry_.erase(&runtime);
+  }
+
+  friend class WorkletRuntimeCollector;
+
+ public:
+  static bool isRuntimeAlive(jsi::Runtime *runtime) {
+    assert(runtime != nullptr);
+    std::lock_guard<std::mutex> lock(mutex_);
+    return registry_.find(runtime) != registry_.end();
+  }
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/lib/module/animationBuilder.js b/node_modules/react-native-reanimated/lib/module/animationBuilder.js
index 55a3d84..d915ed9 100644
--- a/node_modules/react-native-reanimated/lib/module/animationBuilder.js
+++ b/node_modules/react-native-reanimated/lib/module/animationBuilder.js
@@ -37,10 +37,6 @@ export function maybeBuild(layoutAnimationOrBuilder, style, displayName) {
   const isAnimationBuilder = value => 'build' in layoutAnimationOrBuilder && typeof layoutAnimationOrBuilder.build === 'function';
   if (isAnimationBuilder(layoutAnimationOrBuilder)) {
     const animationFactory = layoutAnimationOrBuilder.build();
-    if (__DEV__ && style) {
-      const layoutAnimation = animationFactory(mockTargetValues);
-      maybeReportOverwrittenProperties(layoutAnimation.animations, style, displayName);
-    }
     return animationFactory;
   } else {
     return layoutAnimationOrBuilder;
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/NativeReanimated/NativeReanimated.js b/node_modules/react-native-reanimated/lib/module/reanimated2/NativeReanimated/NativeReanimated.js
index 5cdfa38..b796b87 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/NativeReanimated/NativeReanimated.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/NativeReanimated/NativeReanimated.js
@@ -20,9 +20,6 @@ export class NativeReanimated {
   constructor() {
     _defineProperty(this, "InnerNativeModule", void 0);
     // These checks have to split since version checking depend on the execution order
-    if (__DEV__) {
-      assertSingleReanimatedInstance();
-    }
     global._REANIMATED_VERSION_JS = jsVersion;
     if (global.__reanimatedModuleProxy === undefined) {
       const {
@@ -35,9 +32,6 @@ export class NativeReanimated {
       throw new Error(`[Reanimated] Native part of Reanimated doesn't seem to be initialized.
 See https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#native-part-of-reanimated-doesnt-seem-to-be-initialized for more details.`);
     }
-    if (__DEV__) {
-      checkCppVersion();
-    }
     this.InnerNativeModule = global.__reanimatedModuleProxy;
   }
   makeShareableClone(value, shouldPersistRemote) {
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/PropsRegistry.js b/node_modules/react-native-reanimated/lib/module/reanimated2/PropsRegistry.js
index 906c154..521581a 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/PropsRegistry.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/PropsRegistry.js
@@ -11,9 +11,6 @@ export function removeFromPropsRegistry(viewTag) {
   }
 }
 function flush() {
-  if (__DEV__ && !IS_FABRIC) {
-    throw new Error('[Reanimated] PropsRegistry is only available on Fabric.');
-  }
   runOnUI(removeFromPropsRegistryOnUI)(VIEW_TAGS);
   VIEW_TAGS = [];
 }
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/animation/transformationMatrix/matrixUtils.js b/node_modules/react-native-reanimated/lib/module/reanimated2/animation/transformationMatrix/matrixUtils.js
index effdd4d..a50b146 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/animation/transformationMatrix/matrixUtils.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/animation/transformationMatrix/matrixUtils.js
@@ -89,9 +89,7 @@ function transposeMatrix(matrix) {
 function assertVectorsHaveEqualLengths(a, b) {
   'worklet';
 
-  if (__DEV__ && a.length !== b.length) {
-    throw new Error(`[Reanimated] Cannot calculate inner product of two vectors of different lengths. Length of ${a.toString()} is ${a.length} and length of ${b.toString()} is ${b.length}.`);
-  }
+
 }
 function innerProduct(a, b) {
   'worklet';
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/animation/util.js b/node_modules/react-native-reanimated/lib/module/reanimated2/animation/util.js
index 05fc741..c619623 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/animation/util.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/animation/util.js
@@ -7,9 +7,7 @@ import { flatten, multiplyMatrices, scaleMatrix, addMatrices, decomposeMatrixInt
 import { isReducedMotion, shouldBeUseWeb } from '../PlatformChecker';
 let IN_STYLE_UPDATER = false;
 const IS_REDUCED_MOTION = isReducedMotion();
-if (__DEV__ && IS_REDUCED_MOTION) {
-  console.warn(`[Reanimated] Reduced motion setting is enabled on this device. This warning is visible only in the development mode. Some animations will be disabled by default. You can override the behavior for individual animations, see https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#reduced-motion-setting-is-enabled-on-this-device.`);
-}
+
 export function initialUpdaterRun(updater) {
   IN_STYLE_UPDATER = true;
   const result = updater();
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/hook/useAnimatedStyle.js b/node_modules/react-native-reanimated/lib/module/reanimated2/hook/useAnimatedStyle.js
index 0fe2380..b550523 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/hook/useAnimatedStyle.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/hook/useAnimatedStyle.js
@@ -286,10 +286,7 @@ export function useAnimatedStyle(updater, dependencies, adapters) {
       // let web work without a Babel plugin
       inputs = dependencies;
     }
-    if (__DEV__ && !inputs.length && !dependencies && !isWorkletFunction(updater)) {
-      throw new Error(`[Reanimated] \`useAnimatedStyle\` was used without a dependency array or Babel plugin. Please explicitly pass a dependency array, or enable the Babel plugin.
-For more, see the docs: \`https://docs.swmansion.com/react-native-reanimated/docs/guides/web-support#web-without-the-babel-plugin\`.`);
-    }
+
   }
   const adaptersArray = adapters ? Array.isArray(adapters) ? adapters : [adapters] : [];
   const adaptersHash = adapters ? buildWorkletsHash(adaptersArray) : null;
@@ -305,9 +302,7 @@ For more, see the docs: \`https://docs.swmansion.com/react-native-reanimated/doc
   adaptersHash && dependencies.push(adaptersHash);
   if (!animatedUpdaterData.current) {
     const initialStyle = initialUpdaterRun(updater);
-    if (__DEV__) {
-      validateAnimatedStyles(initialStyle);
-    }
+
     animatedUpdaterData.current = {
       initial: {
         value: initialStyle,
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/runtimes.js b/node_modules/react-native-reanimated/lib/module/reanimated2/runtimes.js
index ef2a0a5..982c554 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/runtimes.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/runtimes.js
@@ -33,9 +33,7 @@ export function createWorkletRuntime(name, initializer) {
 export function runOnRuntime(workletRuntime, worklet) {
   'worklet';
 
-  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {
-    throw new Error('[Reanimated] The function passed to `runOnRuntime` is not a worklet.' + (_WORKLET ? ' Please make sure that `processNestedWorklets` option in Reanimated Babel plugin is enabled.' : ''));
-  }
+
   if (_WORKLET) {
     return function () {
       for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js b/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js
index 2c56566..a6fa513 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js
@@ -108,15 +108,7 @@ export function makeShareableCloneRecursive(value) {
       } else if (isPlainJSObject(value) || isTypeFunction) {
         toAdapt = {};
         if (isWorkletFunction(value)) {
-          if (__DEV__) {
-            const babelVersion = value.__initData.version;
-            if (babelVersion !== undefined && babelVersion !== jsVersion) {
-              throw new Error(`[Reanimated] Mismatch between JavaScript code version and Reanimated Babel plugin version (${jsVersion} vs. ${babelVersion}).        
-See \`https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#mismatch-between-javascript-code-version-and-reanimated-babel-plugin-version\` for more details.
-Offending code was: \`${getWorkletCode(value)}\``);
-            }
-            registerWorkletStackDetails(value.__workletHash, value.__stackDetails);
-          }
+
           if (value.__stackDetails) {
             // `Error` type of value cannot be copied to the UI thread, so we
             // remove it after we handled it in dev mode or delete it to ignore it in production mode.
@@ -184,15 +176,7 @@ Offending code was: \`${getWorkletCode(value)}\``);
         shareableMappingCache.set(value, inaccessibleObject);
         return inaccessibleObject;
       }
-      if (__DEV__) {
-        // we freeze objects that are transformed to shareable. This should help
-        // detect issues when someone modifies data after it's been converted to
-        // shareable. Meaning that they may be doing a faulty assumption in their
-        // code expecting that the updates are going to automatically populate to
-        // the object sent to the UI thread. If the user really wants some objects
-        // to be mutable they should use shared values instead.
-        Object.freeze(value);
-      }
+
       const adopted = NativeReanimatedModule.makeShareableClone(toAdapt, shouldPersistRemote);
       shareableMappingCache.set(value, adopted);
       shareableMappingCache.set(adopted);
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/threads.js b/node_modules/react-native-reanimated/lib/module/reanimated2/threads.js
index 4a34fab..0cb17a2 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/threads.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/threads.js
@@ -61,12 +61,8 @@ export const callMicrotasks = SHOULD_BE_USE_WEB ? () => {
 export function runOnUI(worklet) {
   'worklet';
 
-  if (__DEV__ && !SHOULD_BE_USE_WEB && _WORKLET) {
-    throw new Error('[Reanimated] `runOnUI` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.');
-  }
-  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {
-    throw new Error('[Reanimated] `runOnUI` can only be used on worklets.');
-  }
+
+
   return function () {
     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
       args[_key] = arguments[_key];
@@ -88,15 +84,7 @@ export function runOnUI(worklet) {
       }));
       return;
     }
-    if (__DEV__) {
-      // in DEV mode we call shareable conversion here because in case the object
-      // can't be converted, we will get a meaningful stack-trace as opposed to the
-      // situation when conversion is only done via microtask queue. This does not
-      // make the app particularily less efficient as converted objects are cached
-      // and for a given worklet the conversion only happens once.
-      makeShareableCloneRecursive(worklet);
-      makeShareableCloneRecursive(args);
-    }
+
     _runOnUIQueue.push([worklet, args]);
     if (_runOnUIQueue.length === 1) {
       queueMicrotask(() => {
@@ -141,12 +129,8 @@ export function executeOnUIRuntimeSync(worklet) {
 export function runOnUIImmediately(worklet) {
   'worklet';
 
-  if (__DEV__ && !SHOULD_BE_USE_WEB && _WORKLET) {
-    throw new Error('[Reanimated] `runOnUIImmediately` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.');
-  }
-  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {
-    throw new Error('[Reanimated] `runOnUIImmediately` can only be used on worklets.');
-  }
+
+
   return function () {
     for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
       args[_key3] = arguments[_key3];
diff --git a/node_modules/react-native-reanimated/lib/module/reanimated2/valueUnpacker.js b/node_modules/react-native-reanimated/lib/module/reanimated2/valueUnpacker.js
index fb41439..5b83b61 100644
--- a/node_modules/react-native-reanimated/lib/module/reanimated2/valueUnpacker.js
+++ b/node_modules/react-native-reanimated/lib/module/reanimated2/valueUnpacker.js
@@ -57,24 +57,7 @@ See \`https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshoo
     throw new Error(`[Reanimated] Data type in category "${category}" not recognized by value unpacker: "${_toString(objectToUnpack)}".`);
   }
 }
-if (__DEV__ && !shouldBeUseWeb()) {
-  const testWorklet = () => {
-    'worklet';
-  };
-  if (!isWorkletFunction(testWorklet)) {
-    throw new Error(`[Reanimated] Failed to create a worklet. See https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#failed-to-create-a-worklet for more details.`);
-  }
-  if (!isWorkletFunction(valueUnpacker)) {
-    throw new Error('[Reanimated] `valueUnpacker` is not a worklet');
-  }
-  const closure = valueUnpacker.__closure;
-  if (closure === undefined) {
-    throw new Error('[Reanimated] `valueUnpacker` closure is undefined');
-  }
-  if (Object.keys(closure).length !== 0) {
-    throw new Error('[Reanimated] `valueUnpacker` must have empty closure');
-  }
-}
+
 export function getValueUnpackerCode() {
   return valueUnpacker.__initData.code;
 }
diff --git a/node_modules/react-native-reanimated/src/animationBuilder.tsx b/node_modules/react-native-reanimated/src/animationBuilder.tsx
index 489d4de..59745bd 100644
--- a/node_modules/react-native-reanimated/src/animationBuilder.tsx
+++ b/node_modules/react-native-reanimated/src/animationBuilder.tsx
@@ -88,14 +88,7 @@ export function maybeBuild(
   if (isAnimationBuilder(layoutAnimationOrBuilder)) {
     const animationFactory = layoutAnimationOrBuilder.build();
 
-    if (__DEV__ && style) {
-      const layoutAnimation = animationFactory(mockTargetValues);
-      maybeReportOverwrittenProperties(
-        layoutAnimation.animations,
-        style,
-        displayName
-      );
-    }
+
 
     return animationFactory;
   } else {
diff --git a/node_modules/react-native-reanimated/src/reanimated2/NativeReanimated/NativeReanimated.ts b/node_modules/react-native-reanimated/src/reanimated2/NativeReanimated/NativeReanimated.ts
index 00a52f3..3785303 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/NativeReanimated/NativeReanimated.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/NativeReanimated/NativeReanimated.ts
@@ -85,9 +85,7 @@ export class NativeReanimated {
 
   constructor() {
     // These checks have to split since version checking depend on the execution order
-    if (__DEV__) {
-      assertSingleReanimatedInstance();
-    }
+
     global._REANIMATED_VERSION_JS = jsVersion;
     if (global.__reanimatedModuleProxy === undefined) {
       const { ReanimatedModule } = NativeModules;
@@ -100,9 +98,7 @@ export class NativeReanimated {
 See https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#native-part-of-reanimated-doesnt-seem-to-be-initialized for more details.`
       );
     }
-    if (__DEV__) {
-      checkCppVersion();
-    }
+
     this.InnerNativeModule = global.__reanimatedModuleProxy;
   }
 
diff --git a/node_modules/react-native-reanimated/src/reanimated2/PropsRegistry.ts b/node_modules/react-native-reanimated/src/reanimated2/PropsRegistry.ts
index 911533c..6f31c5d 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/PropsRegistry.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/PropsRegistry.ts
@@ -14,9 +14,7 @@ export function removeFromPropsRegistry(viewTag: number) {
 }
 
 function flush() {
-  if (__DEV__ && !IS_FABRIC) {
-    throw new Error('[Reanimated] PropsRegistry is only available on Fabric.');
-  }
+
   runOnUI(removeFromPropsRegistryOnUI)(VIEW_TAGS);
   VIEW_TAGS = [];
 }
diff --git a/node_modules/react-native-reanimated/src/reanimated2/animation/transformationMatrix/matrixUtils.tsx b/node_modules/react-native-reanimated/src/reanimated2/animation/transformationMatrix/matrixUtils.tsx
index bb8d30c..963e3b9 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/animation/transformationMatrix/matrixUtils.tsx
+++ b/node_modules/react-native-reanimated/src/reanimated2/animation/transformationMatrix/matrixUtils.tsx
@@ -254,13 +254,7 @@ function transposeMatrix(matrix: AffineMatrix): AffineMatrix {
 
 function assertVectorsHaveEqualLengths(a: number[], b: number[]) {
   'worklet';
-  if (__DEV__ && a.length !== b.length) {
-    throw new Error(
-      `[Reanimated] Cannot calculate inner product of two vectors of different lengths. Length of ${a.toString()} is ${
-        a.length
-      } and length of ${b.toString()} is ${b.length}.`
-    );
-  }
+
 }
 
 function innerProduct(a: number[], b: number[]) {
diff --git a/node_modules/react-native-reanimated/src/reanimated2/animation/util.ts b/node_modules/react-native-reanimated/src/reanimated2/animation/util.ts
index f3b4dc8..5f563c8 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/animation/util.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/animation/util.ts
@@ -37,11 +37,7 @@ import { isReducedMotion, shouldBeUseWeb } from '../PlatformChecker';
 let IN_STYLE_UPDATER = false;
 const IS_REDUCED_MOTION = isReducedMotion();
 
-if (__DEV__ && IS_REDUCED_MOTION) {
-  console.warn(
-    `[Reanimated] Reduced motion setting is enabled on this device. This warning is visible only in the development mode. Some animations will be disabled by default. You can override the behavior for individual animations, see https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#reduced-motion-setting-is-enabled-on-this-device.`
-  );
-}
+
 
 export function initialUpdaterRun<T>(updater: () => T) {
   IN_STYLE_UPDATER = true;
diff --git a/node_modules/react-native-reanimated/src/reanimated2/hook/useAnimatedStyle.ts b/node_modules/react-native-reanimated/src/reanimated2/hook/useAnimatedStyle.ts
index 6b74e82..714c403 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/hook/useAnimatedStyle.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/hook/useAnimatedStyle.ts
@@ -431,17 +431,7 @@ export function useAnimatedStyle<Style extends DefaultStyle>(
       // let web work without a Babel plugin
       inputs = dependencies;
     }
-    if (
-      __DEV__ &&
-      !inputs.length &&
-      !dependencies &&
-      !isWorkletFunction(updater)
-    ) {
-      throw new Error(
-        `[Reanimated] \`useAnimatedStyle\` was used without a dependency array or Babel plugin. Please explicitly pass a dependency array, or enable the Babel plugin.
-For more, see the docs: \`https://docs.swmansion.com/react-native-reanimated/docs/guides/web-support#web-without-the-babel-plugin\`.`
-      );
-    }
+
   }
   const adaptersArray = adapters
     ? Array.isArray(adapters)
@@ -462,9 +452,7 @@ For more, see the docs: \`https://docs.swmansion.com/react-native-reanimated/doc
 
   if (!animatedUpdaterData.current) {
     const initialStyle = initialUpdaterRun(updater);
-    if (__DEV__) {
-      validateAnimatedStyles(initialStyle);
-    }
+
     animatedUpdaterData.current = {
       initial: {
         value: initialStyle,
diff --git a/node_modules/react-native-reanimated/src/reanimated2/runtimes.ts b/node_modules/react-native-reanimated/src/reanimated2/runtimes.ts
index 6506495..ba63326 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/runtimes.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/runtimes.ts
@@ -58,14 +58,7 @@ export function runOnRuntime<Args extends unknown[], ReturnValue>(
   worklet: WorkletFunction<Args, ReturnValue>
 ): (...args: Args) => void {
   'worklet';
-  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {
-    throw new Error(
-      '[Reanimated] The function passed to `runOnRuntime` is not a worklet.' +
-        (_WORKLET
-          ? ' Please make sure that `processNestedWorklets` option in Reanimated Babel plugin is enabled.'
-          : '')
-    );
-  }
+
   if (_WORKLET) {
     return (...args) =>
       global._scheduleOnRuntime(
diff --git a/node_modules/react-native-reanimated/src/reanimated2/shareables.ts b/node_modules/react-native-reanimated/src/reanimated2/shareables.ts
index cdb4e9f..119705d 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/shareables.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/shareables.ts
@@ -150,18 +150,6 @@ export function makeShareableCloneRecursive<T>(
       } else if (isPlainJSObject(value) || isTypeFunction) {
         toAdapt = {};
         if (isWorkletFunction(value)) {
-          if (__DEV__) {
-            const babelVersion = value.__initData.version;
-            if (babelVersion !== undefined && babelVersion !== jsVersion) {
-              throw new Error(`[Reanimated] Mismatch between JavaScript code version and Reanimated Babel plugin version (${jsVersion} vs. ${babelVersion}).        
-See \`https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#mismatch-between-javascript-code-version-and-reanimated-babel-plugin-version\` for more details.
-Offending code was: \`${getWorkletCode(value)}\``);
-            }
-            registerWorkletStackDetails(
-              value.__workletHash,
-              value.__stackDetails!
-            );
-          }
           if (value.__stackDetails) {
             // `Error` type of value cannot be copied to the UI thread, so we
             // remove it after we handled it in dev mode or delete it to ignore it in production mode.
@@ -241,15 +229,6 @@ Offending code was: \`${getWorkletCode(value)}\``);
         shareableMappingCache.set(value, inaccessibleObject);
         return inaccessibleObject;
       }
-      if (__DEV__) {
-        // we freeze objects that are transformed to shareable. This should help
-        // detect issues when someone modifies data after it's been converted to
-        // shareable. Meaning that they may be doing a faulty assumption in their
-        // code expecting that the updates are going to automatically populate to
-        // the object sent to the UI thread. If the user really wants some objects
-        // to be mutable they should use shared values instead.
-        Object.freeze(value);
-      }
       const adopted = NativeReanimatedModule.makeShareableClone(
         toAdapt,
         shouldPersistRemote
diff --git a/node_modules/react-native-reanimated/src/reanimated2/threads.ts b/node_modules/react-native-reanimated/src/reanimated2/threads.ts
index dd8ff2f..98ba1b1 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/threads.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/threads.ts
@@ -75,14 +75,8 @@ export function runOnUI<Args extends unknown[], ReturnValue>(
   worklet: WorkletFunction<Args, ReturnValue>
 ): (...args: Args) => void {
   'worklet';
-  if (__DEV__ && !SHOULD_BE_USE_WEB && _WORKLET) {
-    throw new Error(
-      '[Reanimated] `runOnUI` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.'
-    );
-  }
-  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {
-    throw new Error('[Reanimated] `runOnUI` can only be used on worklets.');
-  }
+
+
   return (...args) => {
     if (IS_JEST) {
       // Mocking time in Jest is tricky as both requestAnimationFrame and queueMicrotask
@@ -102,15 +96,7 @@ export function runOnUI<Args extends unknown[], ReturnValue>(
       );
       return;
     }
-    if (__DEV__) {
-      // in DEV mode we call shareable conversion here because in case the object
-      // can't be converted, we will get a meaningful stack-trace as opposed to the
-      // situation when conversion is only done via microtask queue. This does not
-      // make the app particularily less efficient as converted objects are cached
-      // and for a given worklet the conversion only happens once.
-      makeShareableCloneRecursive(worklet);
-      makeShareableCloneRecursive(args);
-    }
+
     _runOnUIQueue.push([worklet as WorkletFunction, args]);
     if (_runOnUIQueue.length === 1) {
       queueMicrotask(() => {
@@ -161,16 +147,8 @@ export function runOnUIImmediately<Args extends unknown[], ReturnValue>(
   worklet: WorkletFunction<Args, ReturnValue>
 ): (...args: Args) => void {
   'worklet';
-  if (__DEV__ && !SHOULD_BE_USE_WEB && _WORKLET) {
-    throw new Error(
-      '[Reanimated] `runOnUIImmediately` cannot be called on the UI runtime. Please call the function synchronously or use `queueMicrotask` or `requestAnimationFrame` instead.'
-    );
-  }
-  if (__DEV__ && !SHOULD_BE_USE_WEB && !isWorkletFunction(worklet)) {
-    throw new Error(
-      '[Reanimated] `runOnUIImmediately` can only be used on worklets.'
-    );
-  }
+
+
   return (...args) => {
     NativeReanimatedModule.scheduleOnUI(
       makeShareableCloneRecursive(() => {
diff --git a/node_modules/react-native-reanimated/src/reanimated2/valueUnpacker.ts b/node_modules/react-native-reanimated/src/reanimated2/valueUnpacker.ts
index 66d6fd2..6fe0bb5 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/valueUnpacker.ts
+++ b/node_modules/react-native-reanimated/src/reanimated2/valueUnpacker.ts
@@ -76,26 +76,6 @@ type ValueUnpacker = WorkletFunction<
   any
 >;
 
-if (__DEV__ && !shouldBeUseWeb()) {
-  const testWorklet = (() => {
-    'worklet';
-  }) as WorkletFunction<[], void>;
-  if (!isWorkletFunction(testWorklet)) {
-    throw new Error(
-      `[Reanimated] Failed to create a worklet. See https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#failed-to-create-a-worklet for more details.`
-    );
-  }
-  if (!isWorkletFunction(valueUnpacker)) {
-    throw new Error('[Reanimated] `valueUnpacker` is not a worklet');
-  }
-  const closure = (valueUnpacker as ValueUnpacker).__closure;
-  if (closure === undefined) {
-    throw new Error('[Reanimated] `valueUnpacker` closure is undefined');
-  }
-  if (Object.keys(closure).length !== 0) {
-    throw new Error('[Reanimated] `valueUnpacker` must have empty closure');
-  }
-}
 
 export function getValueUnpackerCode() {
   return (valueUnpacker as ValueUnpacker).__initData.code;
